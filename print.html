<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Language Design Team</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="welcome.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item "><a href="how_to.html"><strong aria-hidden="true">2.</strong> How do I...?</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="how_to/nominate.html"><strong aria-hidden="true">2.1.</strong> Nominate an issue</a></li><li class="chapter-item "><a href="how_to/design_meeting.html"><strong aria-hidden="true">2.2.</strong> Request a design meeting</a></li><li class="chapter-item "><a href="how_to/propose.html"><strong aria-hidden="true">2.3.</strong> Propose a change to the language</a></li><li class="chapter-item "><a href="how_to/new_lint.html"><strong aria-hidden="true">2.4.</strong> Propose or extend a new lint?</a></li><li class="chapter-item "><a href="how_to/experiment.html"><strong aria-hidden="true">2.5.</strong> Add an experimental feature gate</a></li><li class="chapter-item "><a href="how_to/stabilize.html"><strong aria-hidden="true">2.6.</strong> Stabilize a feature</a></li></ol></li><li class="chapter-item "><a href="decision_process.html"><strong aria-hidden="true">3.</strong> Decision process and principles</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="decision_process/examples.html"><strong aria-hidden="true">3.1.</strong> Decision process examples</a></li><li class="chapter-item "><a href="decision_process/reference.html"><strong aria-hidden="true">3.2.</strong> Decision process reference</a></li></ol></li><li class="chapter-item "><a href="chat_platform.html"><strong aria-hidden="true">4.</strong> Chat platform</a></li><li class="chapter-item "><a href="calendar.html"><strong aria-hidden="true">5.</strong> Calendar</a></li><li class="chapter-item "><a href="meetings.html"><strong aria-hidden="true">6.</strong> Meetings</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="meetings/triage.html"><strong aria-hidden="true">6.1.</strong> Triage meeting</a></li><li class="chapter-item "><a href="meetings/design.html"><strong aria-hidden="true">6.2.</strong> Planning and design meetings</a></li><li class="chapter-item "><a href="meetings/backlog-bonanza.html"><strong aria-hidden="true">6.3.</strong> Backlog bonanza</a></li></ol></li><li class="chapter-item "><a href="design_notes.html"><strong aria-hidden="true">7.</strong> Design notes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design_notes/int_literal_as_float.html"><strong aria-hidden="true">7.1.</strong> Allowing integer literals like 1 to be inferred to floating point</a></li><li class="chapter-item "><a href="design_notes/general_coroutines.html"><strong aria-hidden="true">7.2.</strong> Generalizing coroutines</a></li><li class="chapter-item "><a href="design_notes/fn_type_trait_impls.html"><strong aria-hidden="true">7.3.</strong> Extending the capabilities of compiler-generated function types</a></li><li class="chapter-item "><a href="design_notes/auto_traits.html"><strong aria-hidden="true">7.4.</strong> Auto traits</a></li><li class="chapter-item "><a href="design_notes/eager_drop.html"><strong aria-hidden="true">7.5.</strong> Eager drop</a></li><li class="chapter-item "><a href="design_notes/autoref_ops.html"><strong aria-hidden="true">7.6.</strong> Autoderef and autoref in operators</a></li><li class="chapter-item "><a href="design_notes/copy_ergonomics.html"><strong aria-hidden="true">7.7.</strong> Copy type ergonomics</a></li></ol></li><li class="chapter-item "><a href="roadmaps.html"><strong aria-hidden="true">8.</strong> Roadmaps</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="roadmaps/roadmap-2024.html"><strong aria-hidden="true">8.1.</strong> Roadmap 2024</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Language Design Team</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to the repository for the Rust Language Design Team.  This
page stores our administrative information, meeting minutes, as well
as some amount of design constraints. It's always a
work-in-progress (insert omnipresent mid 90s logo for under
construction here).</p>
<h2 id="what-is-the-lang-team"><a class="header" href="#what-is-the-lang-team">What is the lang team</a></h2>
<p>The lang team generally governs the &quot;surface area&quot; of the language, meaning both what code compiles and what happens when it executes. For new language features, we also assume a general &quot;project management&quot; role, in that we track the feature as it progresses from an idea, to implementation, and finally to stabilization.</p>
<p>Note that implementation itself is governed by the <a href="https://github.com/rust-lang/compiler-team">compiler team</a>. To be very concrete, the lang team controls the spec, and the compiler team approves the implemenation and ensures that it meets the spec. Naturally, though, development is a collaborative process, and it often happens that the spec is altered in response to concerns that arise during implementation.</p>
<p>We also work closely with the <a href="https://github.com/rust-lang/types-team">types team</a>, which owns the details of the type system design in much the same way as the compiler team owns the details of the implementation.</p>
<p>Finally, there are often &quot;grey areas&quot; between the language and library teams, such as the addition of a new standard library trait that reflects a core system capability (e.g., <code>Future</code>). In those cases, the lang team is generally reponsible for deciding if we want the core capability, the libs team owns the API details.</p>
<h2 id="key-links"><a class="header" href="#key-links">Key links</a></h2>
<ul>
<li><a href="https://github.com/orgs/rust-lang/projects/16/">Active initiatives project board</a>
<ul>
<li>Shows you the things that are currently under development (or exploration) within Rust.</li>
<li>You can <a href="./initiatives.html">read more about initiatives here</a>.</li>
</ul>
</li>
<li><a href="./calendar.html">Meeting calendar</a>, <a href="https://github.com/rust-lang/lang-team/tree/master/minutes">triage meeting minutes</a>, <a href="https://github.com/rust-lang/lang-team/tree/master/design-meeting-minutes">design meeting minutes</a>
<ul>
<li>You can <a href="./meetings.html">read more about our meetings here.</a>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lang-team-how-to-guide"><a class="header" href="#lang-team-how-to-guide">Lang team &quot;how to&quot; guide</a></h1>
<p>This section includes instructions on how to do various interactions with the lang team.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nominate-an-issue"><a class="header" href="#nominate-an-issue">Nominate an issue</a></h1>
<p>You can raise issues to lang team attention by tagging them with <code>I-lang-nominated</code>. We scan through nominated issues during our <a href="how_to/../meetings/triage.html">triage meetings</a>. For each issue, we try to answer questions and reach decisions on the question being discussed in the issue.</p>
<h2 id="how-to-nominate"><a class="header" href="#how-to-nominate">How to nominate</a></h2>
<p>Add a <strong>self-sufficient</strong> comment to the issue that explains why you are nominated the issue and includes the text <code>@rustbot label +I-lang-nominated</code>. For example:</p>
<pre><code>@rustbot label +I-lang-nominated

I am nominating this for lang-team attention. We have been discussing the pros/cons of updating the type-checking rules for foo bar. The options on the table are as follows:

* Allow type mismatches: This is good because blah.
* Disallow type mismatches: This is good because blah.

Where should we go from here?
</code></pre>
<p>The ideal comment will identify precisely what question you would like answered. Please try to make the comment easy for us to parse and understand without requiring a lot of context. We encourage links to internals or Zulip so we can dive into the details, but it really helps us give useful answers if you can summarize the key details up front.</p>
<p>If your comment requires more than 5-10 minutes of reading and discussion to understand and effectively respond to, consider <a href="how_to/./design_meeting.html">filing a meeting proposal</a> instead. This will give you ~60 minutes to present your question and the lang team more time to analyze it. We may punt the question back to you with an ask to do so if the question isn't answerable in our triage meeting time.</p>
<h2 id="how-quickly-will-the-lang-team-answer"><a class="header" href="#how-quickly-will-the-lang-team-answer">How quickly will the lang team answer?</a></h2>
<p>We try to be prompt, but sometimes we are not. Othertimes, we discuss the issue, but fail to leave the follow-up comment, because we're only human. Please feel free to raise the topic on Zulip or reach out to a lang team member.</p>
<h2 id="repositories-where-we-look-for-nominations"><a class="header" href="#repositories-where-we-look-for-nominations">Repositories where we look for nominations</a></h2>
<p>Nomination is currently supported on the following repositories:</p>
<ul>
<li>rust-lang/rfcs</li>
<li>rust-lang/rust</li>
<li>rust-lang/reference</li>
<li>rust-lang/lang-team</li>
</ul>
<p>(This set is defined by the <code>nominated</code> list in the <a href="https://github.com/rust-lang/triagebot/blob/master/src/agenda.rs">triagebot source code</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proposing-a-topic-for-a-design-meeting"><a class="header" href="#proposing-a-topic-for-a-design-meeting">Proposing a topic for a design meeting</a></h1>
<p>You can propose a topic for a design meeting by opening an <a href="https://github.com/rust-lang/lang-team/issues/new/choose">Design
meeting proposal</a> issue on the lang-team repository. We schedule meetings in our monthly
planning meeting.</p>
<p>Every design meeting begins by reading a document and leaving comments. That document
must be prepared 24 hours in advance of the design meeting and posted on the issue.
If you propose an issue, you should be willing to prepare that document, or else indicate
who will do the preparation.</p>
<p>Typically, design meetings are associated with active initiatives: you may wish to
<a href="how_to/./propose.html">propose an initiative</a> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proposing-a-change-to-the-language"><a class="header" href="#proposing-a-change-to-the-language">Proposing a change to the language</a></h1>
<p>Do you have an idea for a new language feature? The following page describes the lang team policy around changes to the language.</p>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p>The highlights are these:</p>
<ul>
<li>An <a href="https://github.com/rust-lang/rfcs/#when-you-need-to-follow-this-process">RFC</a> is required for most changes.</li>
<li>Small changes that fit in a PR, have narrow impact, and are uncontroversial can skip the RFC process (<a href="how_to/propose.html#what-constitutes-a-small-addition-or-tweak-to-an-existing-feature">read more</a>).</li>
<li>If you have a lang-team champion and an experienced implementor, you can start <a href="how_to/./experiment.html">experimenting</a> by just adding a feature gate and a tracking issue, but you'll still need an RFC later.</li>
</ul>
<h2 id="complete-flowchart"><a class="header" href="#complete-flowchart">Complete flowchart</a></h2>
<p>The following lays out the complete flow chart for language features. Note that you can click on most of the nodes to read about that step in more detail.</p>
<pre class="mermaid">flowchart TD

subgraph LangTeamChangeProcess [Lang Team Change Process]
TweakToExistingFeature[&quot;How large is your proposed change?&quot;]
LangTeamChampion[&quot;Are you an experienced contributor\nwith a lang team champion?&quot;]
NeedToExperiment[&quot;Do you need to experiment\nbefore you can write RFC?&quot;]

subgraph Stages
    ExperimentalFeatureGateProposed[&quot;Create a tracking issue and\nopen a rust-lang/rust PR proposing\nan experimental feature gate&quot;]
    ExperimentalFeatureGateAccepted[&quot;Experiment is approved. Write code!&quot;]
    RFCOpen[&quot;Open a rust-lang/rfcs PR\nwith the completed RFC&quot;]
    RFCAccepted[&quot;RFC is merged.\nIf needed, create a tracking issue,\n and finalize the implementation&quot;]
    FeatureComplete[&quot;Implementation is complete.\nGain experience with the new feature.&quot;]
    StabilizationProposed[&quot;Author a stabilization report and\nopen a PR stabilizing the feature&quot;]
    Documented[&quot;Author a rust-lang/reference PR\nextending the reference\nto describe the new feature.&quot;]
    StabilizationAccepted[&quot;Stabilization is approved!\nFeature rides the trains into stable.&quot;]
    ChangeProposed[&quot;Open a rust-lang/rust PR and\nnominate for lang team.&quot;]
    ChangeAccepted[&quot;PR is merged.&quot;]
    TypesTeamApproval[&quot;Types team approves the\ninteraction with type system.&quot;]
    StyleTeamNotified[&quot;Style team notified about the new feature.&quot;]
    
    ExperimentalFeatureGateProposed --Seconded--&gt; ExperimentalFeatureGateAccepted
    ExperimentalFeatureGateAccepted --&gt; RFCOpen
    RFCOpen --FCP--&gt; RFCAccepted
    RFCAccepted --&gt; FeatureComplete
    FeatureComplete --&gt; StabilizationProposed
    %% StabilizationProposed --&gt; StabilizationAccepted
    StabilizationProposed --do this--&gt; Documented
    Documented --&gt; StabilizationAccepted
    StabilizationProposed --and this--&gt; TypesTeamApproval
    TypesTeamApproval --&gt; StabilizationAccepted
    StabilizationProposed --and this--&gt; StyleTeamNotified
    StyleTeamNotified --&gt; StabilizationAccepted
    ChangeProposed --FCP proposed and accepted--&gt; ChangeAccepted
    ChangeProposed -- If team feels change\nmerits a second RFC --&gt; RFCOpen
end

TweakToExistingFeature -- Tweak to an existing aspect of Rust --&gt; ChangeProposed
TweakToExistingFeature -- New feature or a complex change --&gt; LangTeamChampion
LangTeamChampion -- Yes --&gt; NeedToExperiment
LangTeamChampion -- No --&gt; RFCOpen
NeedToExperiment -- Yes --&gt; ExperimentalFeatureGateProposed
NeedToExperiment -- No --&gt; RFCOpen
end

%% Drawn from https://coolors.co/25283d-8f3985-a675a1-cea2ac-efd9ce
classDef pink fill:#EFD9CE
classDef tuscany fill:#CEA2AC
class LangTeamChangeProcess pink
class Stages tuscany

click RFCOpen href &quot;https://github.com/rust-lang/rfcs/#when-you-need-to-follow-this-process&quot; &quot;Read about RFCs&quot;
click RFCAccepted href &quot;https://forge.rust-lang.org/lang/rfc-merge-procedure.html&quot; &quot;RFC merge procedure&quot;
click ExperimentalFeatureGateProposed href &quot;./experiment.html&quot; &quot;Read about experimental feature gates&quot;
click ExperimentalFeatureGateAccepted href &quot;./experiment.html&quot; &quot;Read about experimental feature gates&quot;
click StabilizationProposed href &quot;./stabilize.html&quot; &quot;Read about stabilization procedure&quot;
click StabilizationAccepted href &quot;./stabilize.html&quot; &quot;Read about stabilization procedure&quot;
click Documented href &quot;./stabilize.html&quot; &quot;Read about stabilization procedure&quot;
click TypesTeamApproval href &quot;./stabilize.html&quot; &quot;Read about stabilization procedure&quot;
click StyleTeamNotified href &quot;./stabilize.html&quot; &quot;Read about stabilization procedure&quot;
click TweakToExistingFeature href &quot;./propose.html#what-constitutes-a-small-addition-or-tweak-to-an-existing-feature&quot;
click LangTeamChampion &quot;./experiment.html&quot; &quot;Read about experimental feature gates&quot;
click NeedToExperiment &quot;./experiment.html&quot; &quot;Read about experimental feature gates&quot;
</pre>
<h2 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h2>
<h3 id="what-do-the-labels-lang-team-second-and-lang-team-consensus-mean"><a class="header" href="#what-do-the-labels-lang-team-second-and-lang-team-consensus-mean">What do the labels &quot;lang-team second&quot; and &quot;lang-team consensus&quot; mean?</a></h3>
<p>These refer to our <a href="how_to/./decision_process.html">decision process</a>:</p>
<ul>
<li>A <strong>second</strong> means that some <a href="https://www.rust-lang.org/governance/teams/lang">lang team member</a> must champion the idea, but it doesn't require full checkboxes. Instead, the idea goes immediately into &quot;final comment period&quot; (which lasts for 10 days), giving other lang team members a chance to comment on it and raise concerns. We use seconding for <em>reversible decisions</em> that don't commit the language to anything in particular.</li>
<li>A <strong>consensus</strong> means that every <a href="https://www.rust-lang.org/governance/teams/lang">lang team member</a> must check their box and actively approve.</li>
</ul>
<p>In both cases, we currently handle consensus with rfcbot (<code>@rfcbot fcp</code>). For a second, however, the lang team member who initiatives FCP can go ahead and check the boxes of other lang-team members, they can raise concerns if needed. This is a temporary measure until we have first-class support for seconding.</p>
<h3 id="are-rfcs-required-for-every-language-change"><a class="header" href="#are-rfcs-required-for-every-language-change">Are RFCs required for every language change?</a></h3>
<p>No! For small additions or tweaks to existing features, you can simply implement the change, open a PR, and <a href="how_to/./nominate.html">nominate</a> it for lang-team attention. If the change turns out to be complex or controversial, though, we may close the PR and request an RFC instead.</p>
<h3 id="what-constitutes-a-small-addition-or-tweak-to-an-existing-feature"><a class="header" href="#what-constitutes-a-small-addition-or-tweak-to-an-existing-feature">What constitutes a &quot;small addition or tweak to an existing feature&quot;?</a></h3>
<p>We do not require an RFC for everything. Small changes that fit in a single PR, have narrow impact, and are uncontroversial can skip the RFC process. Simply make the change, open the PR, and <a href="how_to/./nominate.html">nominate</a> it for lang-team feedback. But be aware that we may still ask you to write an RFC! The rule of thumb is that we use RFCs for ideas that impact a lot of users or are potentially controversial. They're a great way to get broad feedback from the community about an idea.</p>
<p><strong>If you choose to open a PR without an RFC, please document the motivation and details of your change!</strong> Very often people will open a PR that changes some code in the compiler without clearly explaining what they are trying to achieve. Also, please make the explanation &quot;self sufficient&quot; -- avoid linking to internals threads or other places where we have to read a bunch of context to understand what is going on (it's encouraged, however, to provide a summary and link to threads for more details).</p>
<p>Some examples where RFCs are typically NOT required...</p>
<ul>
<li>Narrow changes like adding support for a new ABI (this may even just be a compiler concern).</li>
<li>Soundness fixes to existing features, unless they have large impact or change the way people have to write Rust, in which case we may opt for an RFC.</li>
<li>Small changes to complex rules, such as name resolution, intended to address a particular problem and which don't impact most users; often in cases like these RFCs do not provide valuable feedback, and so we'll instead focus on getting the relevant experts to weigh in. <strong>This category in particular still needs to have a detailed write-up.</strong></li>
<li>Extending a lint to cover more instances of the same general pattern, or to be more precise.</li>
<li>Proposing a new lint that is narrow in scope.</li>
</ul>
<h3 id="what-is-the-policy-for-adding-a-new-lint"><a class="header" href="#what-is-the-policy-for-adding-a-new-lint">What is the policy for adding a new lint?</a></h3>
<p>We have a streamlined process for most lint proposals. See the <a href="how_to/./new_lint.html">How do I add a new lint?</a> for details.</p>
<h3 id="do-experiments-always-require-an-rfc"><a class="header" href="#do-experiments-always-require-an-rfc">Do experiments <em>always</em> require an RFC?</a></h3>
<p>In the diagram above, we show experiments as always leading to an RFC. This is typically the case because experiments tend to be for larger, more ambitious features. However, if the experiment turns out to be a relatively small change to the language -- i.e., some change that would not require an RFC anyway -- then you can skip the RFC and move straight to stabilization.</p>
<h3 id="what-about-adding-special-traits-and-things-to-the-standard-library"><a class="header" href="#what-about-adding-special-traits-and-things-to-the-standard-library">What about adding special traits and things to the standard library?</a></h3>
<p>We consider intrinsics and &quot;lang item&quot; (things that need special treatment from the language) to be under the lang team purview. Specifically, the lang team governs the semantics and capabilities exposed by this new feature. The details of the API are governed by the <a href="https://github.com/rust-lang/libs-team">libs-api team</a>.</p>
<p>Whenever possible, though, we prefer to issue a quick approval for the &quot;general feature&quot; being discussed, and leave it to the libs-api team to decide where to apply it. For example, we approved the ability to add inherent methods to standard library types like <code>u32</code> long ago, but the <a href="https://github.com/rust-lang/libs-team">libs-api team</a> governs what APIs are available.</p>
<h3 id="my-rfc-has-been-waiting-for-a-comment-from-the-lang-team-for-a-long-time"><a class="header" href="#my-rfc-has-been-waiting-for-a-comment-from-the-lang-team-for-a-long-time">My RFC has been waiting for a comment from the lang-team for a long time!</a></h3>
<p>First off, I'm sorry, that sucks. We are aware that we need to do a better job keeping up with RFCs. :/ That said, what you can do is to <a href="how_to/./nominate.html">nominate</a> the RFC and we will discuss it during the meeting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-i-propose-a-new-lint-or-extend-an-existing-one"><a class="header" href="#how-do-i-propose-a-new-lint-or-extend-an-existing-one">How do I propose a new lint, or extend an existing one?</a></h1>
<p>For small lints, you can follow the <a href="how_to/./propose.html">policy for smaller changes</a>: implement the lint, open a PR, and then <a href="how_to/./nominate.html">nominate</a> it for lang-team attention. </p>
<p>We may request an RFC if:</p>
<ul>
<li>the lint is on (warn or higher level) by default, and is expected to affect a lot of users</li>
<li>the lint is controversial</li>
<li>the lint sets a (new) direction for Rust -- for example, changing an existing pattern to a different one, even if the pattern isn't widely used
<ul>
<li>e.g., deprecating a syntax to make room for a possible new language feature</li>
</ul>
</li>
</ul>
<p>If in doubt, you can always raise the idea on Zulip first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="experimental-feature-gates"><a class="header" href="#experimental-feature-gates">Experimental feature gates</a></h1>
<p>We use &quot;experimental feature gates&quot; to allow experienced Rust contributors to start implementing and exploring features even before an RFC has been written. This is particularly useful for larger features where we know we definitely want to solve the problem, but there are a lot of unknowns to work out before we can really create a coherent RFC -- think of things like adding async functions or the like.</p>
<h2 id="process"><a class="header" href="#process">Process</a></h2>
<p>If you are an experienced Rust contributor who would like to start an experiment in-tree, the process is as follows:</p>
<ul>
<li>Write-up a description of the problem you are trying to solve and the general shape of the solution you want to work on. Discuss it on Zulip or elsewhere to find a <strong>lang-team champion</strong>:
<ul>
<li>The champion is the connection to the lang-team. They can check in with you from time to time to see how the work is going and relay those updates to the lang-team (of course, you're always welcome to join meetings yourself too!). They can also help to discuss problems that arise.</li>
</ul>
</li>
<li>Once you've found a champion, open a PR adding a new feature gate to the compiler and create an associated tracking issue.
<ul>
<li>The PR and tracking issue should include a write-up documenting the motivation and outline of what they are trying to achieve. </li>
<li>The feature gate should be marked as 'experimental', so that users get warnings if they try to use it. This flag has to stay until an RFC is accepted, even if the implementation is in good shape.</li>
</ul>
</li>
<li>The lang-team champion will &quot;second&quot; the PR, starting an FCP. Once the FCP completes, the PR can land and implementation work begins (always gated under the new feature gate).
<ul>
<li><strong>Approving a new feature gate does not imply support for the feature.</strong> It implies only that the lang team thinks it is worth doing the experiment to see what results.</li>
<li>Note to lang team members: If you have concerns about the feasibility or wisdom of the feature, the right course of action is usually to allow experimentation to continue, but ensure that your concerns are noted on the tracking issue. This allows the experimentors to try and gather data and address your concern.</li>
</ul>
</li>
<li>When you feel the design is ready, you write an RFC as normal with your proposal. The goal of the experimentation period is simply to gain experience and information so that a better RFC can be authored.</li>
</ul>
<h2 id="frequently-asked-questions-1"><a class="header" href="#frequently-asked-questions-1">Frequently asked questions</a></h2>
<h3 id="what-is-the-role-of-the-lang-team-champion"><a class="header" href="#what-is-the-role-of-the-lang-team-champion">What is the role of the lang team champion?</a></h3>
<p>The lang team champion is the connection to the lang team. They should be available to discuss progress and generally track what's going on, and they can also raise questions to the broader lang team during triage meetings and the like (of course, the meetings are open, so you're also welcome to join if you are able).</p>
<h3 id="ive-got-an-idea-how-do-i-find-a-lang-team-champion"><a class="header" href="#ive-got-an-idea-how-do-i-find-a-lang-team-champion">I've got an idea, how do I find a lang-team champion?</a></h3>
<p>We don't really have a process for that, but circulating the idea on Zulip is a good idea, or perhaps reach out to lang-team members that you know.</p>
<h3 id="why-is-experimentation-limited-to-experienced-contributors"><a class="header" href="#why-is-experimentation-limited-to-experienced-contributors">Why is experimentation limited to experienced contributors?</a></h3>
<p>We've found that it works best when the person driving the experiment is able to move independently and without mentoring. Most folks on the lang team have limited bandwidth, so when they agree to serve as champion, they are committing to meet regularly, give feedback on your progress, and to circulate ideas within the lang team, but they are not necesarily going to have time to help find solutions to problems beyond that ((many lang team members aren't that familiar with the compiler details anyway). </p>
<h3 id="what-if-ive-got-an-implementation-on-a-branch-already"><a class="header" href="#what-if-ive-got-an-implementation-on-a-branch-already">What if I've got an implementation on a branch already?</a></h3>
<p>What we're really looking for in experimentors is commitment and the ability to see the work through. If you're able to implement the idea in a branch, that's good evidence. See if you can find a lang-team champion.</p>
<h3 id="can-a-lang-team-member-propose-an-experiment-too"><a class="header" href="#can-a-lang-team-member-propose-an-experiment-too">Can a lang-team member propose an experiment, too?</a></h3>
<p>Lang-team members can be the one to propose an experiment, and can serve as their own champion, but they should find someone else to &quot;second&quot; the FCP on the feature gate PR.</p>
<h3 id="what-if-im-not-an-experienced-contributor-but-i-have-a-mentor-who-is"><a class="header" href="#what-if-im-not-an-experienced-contributor-but-i-have-a-mentor-who-is">What if I'm not an experienced contributor, but I have a mentor who is?</a></h3>
<p>That's fine, you can still open the PR, but your mentor should be the one to nominate it for lang-team consideration.</p>
<h3 id="what-if-im-an-experienced-contributor-and-i-want-to-mentor-someone"><a class="header" href="#what-if-im-an-experienced-contributor-and-i-want-to-mentor-someone">What if I'm an experienced contributor, and I want to mentor someone?</a></h3>
<p>See the previous question.</p>
<h3 id="as-the-experimentor-what-do-i-do-when-i-feel-like-i-am-ready-to-write-the-rfc"><a class="header" href="#as-the-experimentor-what-do-i-do-when-i-feel-like-i-am-ready-to-write-the-rfc">As the experimentor, what do I do when I feel like I am ready to write the RFC?</a></h3>
<p>Glad to hear the experiment was a success! Check in with the champion to figure out if they feel like it's time to author the RFC. In particular, if people raised concerns about the design in the beginning, make sure that you have a good answer for them. Even better, show them the answer, and see if they are convinced!</p>
<h3 id="as-the-experimentor-what-if-i-feel-like-we-dont-want-the-feature-after-all"><a class="header" href="#as-the-experimentor-what-if-i-feel-like-we-dont-want-the-feature-after-all">As the experimentor, what if I feel like we don't want the feature after all?</a></h3>
<p>This is also a very useful finding! In this case, it's best to write up a comment (potentially short) on the tracking issue reflecting the findings from the experimentation phase, and suggest to your lang team champion that the tracking issue may want to be fcp'd to close so we can remove the feature from the compiler.</p>
<p>It's generally a good idea to do this for features that aren't being actively driven to conclusion and are in the experimental phase, as they can easily accumulate otherwise.</p>
<h3 id="as-the-experimentor-what-if-i-run-out-of-time-to-drive-this-proposal"><a class="header" href="#as-the-experimentor-what-if-i-run-out-of-time-to-drive-this-proposal">As the experimentor, what if I run out of time to drive this proposal?</a></h3>
<p>First off, it's always ok to take a break. If you are going to step away for a long time, you should at minimum leave a comment with your current thinking on things -- if nothing else, it'll help you remember what was going on when you come back. </p>
<p>If you feel like you have to step away indefinitely, then discuss with the champion. They may be able to find someone else, or it may make sense to simply write-up your findings and remove the feature from the compiler.</p>
<h3 id="as-a-lang-team-member-what-do-i-do-if-i-feel-like-my-concerns-are-not-being-addressed"><a class="header" href="#as-a-lang-team-member-what-do-i-do-if-i-feel-like-my-concerns-are-not-being-addressed">As a lang team member, what do I do if I feel like my concerns are not being addressed?</a></h3>
<p>Bring up your concerns with the lang team champion and try to work towards finding experiments or new approaches that can resolve them. If this feature is ever going to make it to RFC, they are going to need your agreement, after all!</p>
<h3 id="what-if-i-have-a-competing-proposal-can-i-land-my-own-experimental-feature"><a class="header" href="#what-if-i-have-a-competing-proposal-can-i-land-my-own-experimental-feature">What if I have a competing proposal? Can I land my own experimental feature?</a></h3>
<p>Obviously the <em>best</em> is if you can combine your idea with the existing experiment, particularly if your idea is a minor variation. But it is also ok to have multiple competing experiments, if the idea is going in a different direction. Just follow the same process (find a lang team champion, etc). Be sure to note in the PR etc that you know this overlaps with the existing experiment and are looking to explore a different part of the design space. Also, it will be really helpful if you and the other experimenters can jointly maintain a kind of FAQ comparing and contrasting the two ideas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stabilize-a-feature"><a class="header" href="#stabilize-a-feature">Stabilize a feature</a></h1>
<p>The final step in the <a href="how_to/./propose.html">language-change process</a> is to <strong>stabilize</strong> a feature. Stabilization works as follows:</p>
<ul>
<li>Author a <a href="https://rustc-dev-guide.rust-lang.org/stabilization_guide.html">stabilization report</a>:
<ul>
<li>Briefly recap the feature's design from the RFC -- you don't have to go into detail, we can re-read the RFC.</li>
<li>Give detailed descriptions of how the feature's design has changed since the RFC was approved!</li>
<li>Summarize any major decisions that were made during the implementation process.</li>
<li>Verify that the feature is fully implemented. Look for tests covering all the major pieces of the RFC and include them in the stabilization report.</li>
<li>Provide answers to any &quot;unresolved questions&quot; listed in the RFC.</li>
<li>Describe the implementation history of the feature (optional).</li>
</ul>
</li>
<li>Prior to stabilizing, we need to coordinate with other teams:
<ul>
<li>An open PR editing the reference to describe the change is required. (You don't personally have to author it, but there needs to be an open PR, and ideally one that has been edited and is approved modulo actual stabilization by one of the repo maintainers.)</li>
<li>If the feature affects the type system, you should nominate for @rust-lang/types to check for their approval.</li>
<li>If the feature adds new syntax, you should should nominate for the style team to get their approval.</li>
</ul>
</li>
<li>The lang team will read the report and eventually move to FCP. Per our <a href="how_to/../decision_process.html">decision process</a>, full consensus is required, as this is an irreversible change.</li>
</ul>
<p>See also the rustc-dev-guide's <a href="https://rustc-dev-guide.rust-lang.org/stabilization_guide.html">stabilization guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This section documents the work-in-progress Rust language team decision
process. This process, and the <code>rustbot</code> tooling to support it, does not yet
have a finished implementation. This document serves to explain the intended
process, for the purposes of ongoing implementation.</p>
<h2 id="prioritized-principles-of-rust-team-consensus-decision-making"><a class="header" href="#prioritized-principles-of-rust-team-consensus-decision-making">Prioritized principles of Rust team consensus decision-making</a></h2>
<p>These are in order of priority. They're intended to be general enough that they
could apply to any Rust governance team, not just the language team.</p>
<ul>
<li><strong>Treasure dissent.</strong> When someone raises a concern, that's a chance to
improve the design, and to discover and explore underlying values. Dissent
should be an amicable, cooperative process.</li>
<li><strong>Understand and cooperatively resolve concerns.</strong> We cannot resolve a
concern without first understanding it, including the underlying values
motivating it. We should demonstrate that understanding by documenting the
concern. We should consider the tradeoffs and the impacts on users, through
the Rust design principles. We should seek out and favor satisfying solutions
(those that satisfy everyone's values) over
<a href="https://en.wikipedia.org/wiki/Satisficing">satisficing</a> solutions (those
that are just good enough for people to accept them as a compromise among
conflicting values, without actually being happy with the outcome).</li>
<li><strong>Don't force an irreversible decision.</strong> We should make decisions
reversible whenever we can. When making a necessarily irreversible decision
(e.g. stabilizing a feature), we should pay close attention to dissent, and
hesitate before overriding objections. If possible, we should seek a better
alternative, or seek common ground we can find consensus on, or seek an
intermediate step that addresses the same use case and supports evaluation
for a more informed decision in the future. If none of those are possible,
consider the null alternative; not making a change should always be the
easier path, and the burden of proof to override a concern on an irreversible
decision should be high.</li>
<li><strong>Value expertise.</strong> When cooperatively resolving a concern, or when
considering overriding a concern, carefully weigh the advice and
recommendations of experts. This includes team advisors, domain experts, and
the owners or members of relevant initiatives.</li>
<li><strong>Recording reasoning helps ensure good, consistent decisions over time.</strong>
Even if we decide not to sustain an objection, we should always record the
objection and the reasons for our decision as a &quot;dissent&quot;, as well as any
unresolved questions for evaluation later in the process. The team member who
raised the objection has the perogative to author that dissent and frame the
unresolved questions (within reason).</li>
<li><strong>Consensus doesn't mean unanimity.</strong> Consensus means everyone is heard and
understood, and all concerns are addressed (even those not treated as
blocking), and the team finds the outcome reasonable. Consensus does not mean
everyone agrees completely.</li>
</ul>
<h2 id="consensus-decision-making-process"><a class="header" href="#consensus-decision-making-process">Consensus decision-making process</a></h2>
<p>First, see <a href="./decision_process/examples.html">some examples of the decision-making process in
action</a>. Then, read the <a href="./decision_process/reference.html">decision process
reference</a> for the full process and the
<code>rustbot</code> tooling to support it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-of-the-decision-making-process-in-action"><a class="header" href="#examples-of-the-decision-making-process-in-action">Examples of the decision-making process in action</a></h1>
<h2 id="reversible-decision-merging-a-proposal"><a class="header" href="#reversible-decision-merging-a-proposal">Reversible decision: merging a proposal</a></h2>
<p>The process is best described by example. Suppose that there is a pending lang
team proposal, and a lang team member would like to serve as the liaison. They
contact the team leads and receive the go-ahead. They can then write:</p>
<blockquote>
<p>@rustbot merge</p>
<p>I propose to merge this proposal. I think it will be a great addition to
Rust!</p>
</blockquote>
<p>This indicates that they would like to merge the proposal. At the moment, there
is no decision pending, so rustbot would add a comment that looks like the
following:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or
cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td></td></tr>
</tbody></table>
</div></blockquote>
<p>As the comment says, the PR is now in &quot;pending decision&quot; state, with Alan
having kicked off the process with a proposal to merge. Alan's status of
<strong>merge</strong> will link to his comment.</p>
<p>Now, for this particular proposal, Barbara has a concern. She thinks that the
proposal has overlooked an important consideration. She writes a comment:</p>
<blockquote>
<p>@rustbot hold</p>
<p>Did you consider reversing the polarity? Or the impact on the flux capacitor?</p>
</blockquote>
<p>At this point, rustbot updates the state; Barbara's status of
<strong>hold</strong> will link to her comment:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><strong>hold</strong></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td></td></tr>
</tbody></table>
</div></blockquote>
<p>Alan is currently busy at work, though, so by the time that he and Barbara
get a chance to talk, 11 days have passed. (Alan and Barbara receive a ping
from rustbot after a week or so.) Once they get a chance to talk, Alan
fully addresses Barbara's concern, so Barbara posts:</p>
<blockquote>
<p>@rustbot merge</p>
</blockquote>
<p>The comment is updated:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>hold</del> <strong>merge</strong></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td></td></tr>
</tbody></table>
</div></blockquote>
<p>Barbara's previous <del>hold</del> status links to her previous comment setting her
status to <code>hold</code>, and her current <strong>merge</strong> status links to her more recent
comment setting her status to <code>merge</code>.</p>
<p>At this point, all the statuses are either empty or <strong>merge</strong>, and more than 10
days have passed since the FCP started. Therefore, it completes immediately.</p>
<h2 id="authoring-an-rfc-illustration-of-rustbot-restart"><a class="header" href="#authoring-an-rfc-illustration-of-rustbot-restart">Authoring an RFC (illustration of <code>rustbot restart</code>)</a></h2>
<p>After some time, the proposal is completed and an RFC is proposed. This is a
reversible decision. Alan, as the liaison, proposes to merge the RFC with
<code>@rustbot merge</code>, and the decision making process proceeds as above.</p>
<p>This time, Niklaus has a concern:</p>
<blockquote>
<p>@rustbot hold</p>
<p>I have not had time to read this yet! Give me a bit of time to write it up.</p>
</blockquote>
<p>After 7 days have passed, rustbot writes to him:</p>
<blockquote>
<p>@Niklaus, I see you have placed a hold but 7 days have passed. Are you any
closer to reaching a decision? (cc @Alan)</p>
</blockquote>
<p>This continues for a week or two while Alan and Niklaus play &quot;email tag&quot;. In
the interim, Barbara decides she agrees with the RFC, so she uses <code>@rustbot merge</code> as well. The status now looks like this:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this PR. This is a <strong>reversible
decision</strong>, which means that it will be affirmed once the &quot;final comment
period&quot; of 10 days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).
decision.</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><strong>merge</strong></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td><strong>hold</strong></td></tr>
</tbody></table>
</div></blockquote>
<p>Eventually, Alan and Niklaus find a time to discuss, and Alan agrees that
Niklaus's concerns are valid, so he makes some major edits to the RFC. Given
that the RFC is completely different, he decides to restart the clock and
writes:</p>
<blockquote>
<p>@rustbot restart</p>
</blockquote>
<p>This strikes through the state of all team members (setting their current
status to blank, while preserving the history) and begins the clock anew.
rustbot also pings the relevant team members:</p>
<blockquote>
<p>Dear @rust-lang/team, @Alan has restarted the clock!</p>
</blockquote>
<p>The status now looks like this:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>merge</del></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td><del>hold</del></td></tr>
</tbody></table>
</div></blockquote>
<p>Barbara can use <code>@rustbot merge</code> to re-affirm her <strong>merge</strong> status, and Niklaus
can use <code>@rustbot merge</code> to set his own status to <strong>merge</strong> since he agrees
with the resolution of his concern.</p>
<h2 id="authoring-an-rfc-continued-overriding-a-concern"><a class="header" href="#authoring-an-rfc-continued-overriding-a-concern">Authoring an RFC continued (Overriding a concern)</a></h2>
<p>At this point, Grace has a concern, and explains that concern in detail:</p>
<blockquote>
<p>@rustbot hold</p>
<p>I've thought about this a lot, and I don't think we should do this. Now that
I see the syntax used in practice, I feel like if we do this it'll have an
adverse effect on the ecosystem...</p>
</blockquote>
<p>The status now looks like this:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>merge</del> <strong>merge</strong></td></tr>
<tr><td>@Grace</td><td><strong>hold</strong></td></tr>
<tr><td>@Niklaus</td><td><del>hold</del> <strong>merge</strong></td></tr>
</tbody></table>
</div></blockquote>
<p>Niklaus reads this message. He feels he understands the concern well, and
agrees that this point hasn't yet been considered:</p>
<blockquote>
<p>@rustbot hold</p>
<p>I agree. I think we should take more time to evaluate alternative syntaxes.
What about...</p>
</blockquote>
<p>Over the course of a few subsequent meetings and side conversations, Grace and
other team members discuss the concern further; the initiative owner also
considers the concern, and raises it with others working on the initiative.</p>
<p>The owner of the initiative updates the RFC to include a discussion of a couple
of alternative syntax proposals. The owner recommends a slightly modified
version of the originally proposed syntax, and outlines criteria that they feel
the syntax should meet in order to support the use case.</p>
<p>Grace agrees that her concern has been understood, but does not agree with the
proposed syntax. Grace feels the new proposal is an improvement, but her
concern remains.</p>
<p>Niklaus feels that the team has understood Grace's concern, and furthermore,
that the updated proposal addresses Grace's concern:</p>
<blockquote>
<p>@rustbot merge</p>
<p>I appreciate the potential impact this may have on the ecosystem. However, I
feel that as now described in section XYZ of the RFC, the value of A
outweighs the risk of B, and I think C mitigates the potential risk by...</p>
</blockquote>
<p>(Notice that while Niklaus feels that the team has understood Grace's concern,
he does not speak for the entire team or imply that his summary represents the
entire team. Niklaus is just withdrawing his own support for the concern.)</p>
<p>At this point, the entire team other than Grace agrees that the proposal should
move forward:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>merge</del> <strong>merge</strong></td></tr>
<tr><td>@Grace</td><td><strong>hold</strong></td></tr>
<tr><td>@Niklaus</td><td><del>hold</del> <del>merge</del> <del>hold</del> <strong>merge</strong></td></tr>
</tbody></table>
</div></blockquote>
<p>(We'll assume, for this example, that Grace does not manage to convince anyone
else.)</p>
<p>Grace takes some time, working with the RFC author, to add a dissent, including
a specific unresolved question.</p>
<p>Grace then writes a comment containing <code>@rustbot dissent</code>. (If necessary, or if
Grace would prefer, another team member may issue <code>@rustbot @grace dissent</code> on
her behalf.) The status now looks like this:</p>
<blockquote>
<p>Hello! @Alan has proposed to merge this. This is a <strong>reversible decision</strong>,
which means that it will be affirmed once the &quot;final comment period&quot; of 10
days have passed, unless a team member places a &quot;hold&quot; on the decision (or cancels it).</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td><strong>merge</strong></td></tr>
<tr><td>@Barbara</td><td><del>merge</del> <strong>merge</strong></td></tr>
<tr><td>@Grace</td><td><del>hold</del> <strong>dissent</strong></td></tr>
<tr><td>@Niklaus</td><td><del>hold</del> <del>merge</del> <del>hold</del> <strong>merge</strong></td></tr>
</tbody></table>
</div></blockquote>
<p>Since all statuses are now either <strong>merge</strong> or <strong>dissent</strong> rustbot also posts a
comment:</p>
<blockquote>
<p>The final comment period has resolved, with a decision to <strong>merge</strong>.</p>
<p>Note that this decision has dissents; please ensure these dissents have been
recorded for subsequent consideration.</p>
</blockquote>
<h2 id="stabilizing-a-feature"><a class="header" href="#stabilizing-a-feature">Stabilizing a feature</a></h2>
<p>The feature has been implemented and is now eligible for stabilization. Alan
writes a stabilization report and posts it, and then issues the command</p>
<blockquote>
<p>@rustbot stabilize</p>
</blockquote>
<p>Rustbot recognizes that a &quot;stabilization&quot; decision is irreversible, so the
template is a bit different:</p>
<blockquote>
<p>Hello! @Alan has proposed to stabilize this. This is a <strong>irreversible
decision</strong>, which means that it will be affirmed once all members come to a
consensus and the &quot;final comment period&quot; of 10 days has passed.</p>
<div class="table-wrapper"><table><thead><tr><th>Team member</th><th>State</th></tr></thead><tbody>
<tr><td>@Alan</td><td>stabilize</td></tr>
<tr><td>@Barbara</td><td></td></tr>
<tr><td>@Grace</td><td></td></tr>
<tr><td>@Niklaus</td><td></td></tr>
</tbody></table>
</div></blockquote>
<p>This time, Barbara, Grace, and Niklaus must all explicitly provide a status
before the decision can proceed. One by one, they join the PR. They must
individually set their state using one of the rustbot commands.</p>
<p>Niklaus reads this and comments with <code>@rustbot merge</code>. But then, Niklaus uses
the feature and discovers a crucial flaw. He posts a comment:</p>
<blockquote>
<p>@rustbot close</p>
<p>After more testing, I believe this is not ready for stabilization. I have
found that it doesn't work at all like the specification in the case of foo!
This seems closely related to Grace's concern on the RFC; I think if we
stabilize at this point we may indeed harm the ecosystem...</p>
</blockquote>
<p>Other team members test as well, and find that Niklaus is right. Alan changes
his status using <code>@rustbot close</code>, and Grace (with some relief) sets the same
status.</p>
<p>Once everyone has changed their status, rustbot posts a comment:</p>
<blockquote>
<p>The final comment period has resolved, with a decision to <strong>close</strong>.</p>
</blockquote>
<p>(Note: Since <code>close</code> is an inherently reversible status (a PR can always be
reopened), rustbot can observe that everyone has set a reversible status, and
will start treating the decision as reversible; this means the final comment
period can end even if Barbara hasn't responded yet.)</p>
<p>This may not be the end of this feature's consideration, and the concern might
get resolved in many different ways. The initiative owner might need to do some
additional design work on how to solve the original use case and address the
concern; implementers may find a way to address the concern by improving the
implementation; or the team may change their mind.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decision-making-process-detailed-description"><a class="header" href="#decision-making-process-detailed-description">Decision-making process, detailed description</a></h1>
<ul>
<li>Entering a &quot;decision period&quot; can be done by having a team member tell rustbot
an initial status (<code>merge</code>, <code>stabilize</code>, or <code>close</code>; or, <code>reversible</code> or
<code>irreversible</code> with a custom identifier).
<ul>
<li>All other team members have no initial status set.</li>
<li>During a reversible decision period, if later commenters indicate the
decision is irreversible, the decision changes to irreversible.</li>
<li>During an irreversible decision period, if all commenters change their
status to a reversible status (most commonly <code>close</code>), the decision becomes
reversible.</li>
<li>Bot commands accept <code>mut</code>/<code>mutable</code>/<code>rev</code> as synonyms for <code>reversible</code>, and
<code>immut</code>/<code>immutable</code>/<code>irrev</code> as synonyms for <code>irreversible</code>.</li>
</ul>
</li>
<li>Once the &quot;decision period&quot; has begun, a clock of 10 days starts. The clock is
never paused unless an explicit <code>@rustbot restart</code> command is given.</li>
<li>The <code>restart</code> command sets the decision period back to its initial state
(members' current statuses are also set back to blank, though the history of
their previous statuses is preserved as with any other status change).</li>
<li>A decision is reached when the following conditions are met:
<ul>
<li>At least 10 days have elapsed since the decision period began (or when it
was last <code>restart</code>ed).</li>
<li>Everyone is set to the same status, or to <code>abstain</code>, or to <code>dissent</code> (with
at most one <code>dissent</code> status), or (for a reversible decision only) blank.</li>
</ul>
</li>
<li>Member may place a <em>hold</em> (raise a concern) at any phase of the process:
proposal, experimentation, testing, stabilization. Ideally, concerns should
be raised as early as possible.
<ul>
<li>In general, one of the liaison's jobs is to anticipate concerns that may
arise and reach out proactively to the members of the team. If we find that
team members regularly need to place serious holds for similar reasons,
that may indicate we need to work harder at team calibration.</li>
</ul>
</li>
<li>&quot;Holding&quot; a decision is simple. If you have a potential concern that you
haven't had a chance to fully articulate yet, you get periodic pings.</li>
<li>In order to proceed after a concern is raised, whether sustaining the concern
or overriding the concern, the team must understand the concern. This
understanding should be expressed in writing rather than just verbally.
Commonly, the owner of an initiative/proposal may incorporate the concern
into the proposal and address it there (whether via their own words or those
of a team member).
<ul>
<li>Ideally, a concern is only considered &quot;understood&quot; if the objector agrees
it has been. If that is not possible, then everyone on the team other than
the objector must unanimously agree that there is no further understanding
to be gained. (In practice, this agreement is determined by whether anyone
on the team is willing to support the objection.)</li>
</ul>
</li>
<li>If the owner feels that the concern has been adequately addressed, they can
produce a write-up that describes the concern and request a poll of the team
members to see where everyone stands.
<ul>
<li>Sustaining an objection requires one team member other than the objector. A
team member should sustain an objection if either they believe the
objection has been understood and they agree that it must be addressed, or
if they believe the objection has not been fully understood (whether they
personally agree with it or not).</li>
<li>If everyone else agrees that the concern has been understood <em>and</em> that the
current design is sufficient, then the concern is <em>overridden</em>.</li>
<li>Team members are encouraged to regularly sustain objections they don't
personally agree with, if they believe the objection has not yet been fully
understood; this is a normal and valuable part of the process.</li>
</ul>
</li>
<li>Whenever a concern is overridden, team members are encouraged to add a
<strong>dissent</strong> into the document to describe their concern and why they don't
agree with the decision. They (or another team member) should then set their
status to <code>dissent</code>.</li>
</ul>
<h1 id="rustbot-commands"><a class="header" href="#rustbot-commands">Rustbot commands</a></h1>
<p>The following commands are accepted by rustbot. (Commands written below omit
the required <code>@</code> on rustbot to avoid invoking rustbot when quoting the
documentation.) A number of comments take one or more optional <code>@member</code>
arguments, denoted <code>@member*</code>; if supplied, the command is issued on behalf of
those member(s), instead of the person writing the command. (The <code>@</code> for each
member is required.) It is also permitted to write <code>@rust-lang/team</code> to select
all members of the team. rustbot will always link from each member's row in the
table to each comment changing their status.</p>
<ul>
<li><code>rustbot @member* reversible ident</code> or <code>rustbot @member* mutable ident</code>
(unambiguous prefixes such as <code>mut</code> or <code>rev</code> also work)
<ul>
<li>If not in a decision period: begin a reversible (&quot;mutable&quot;) decision,
proposing the outcome <code>ident</code>; all other members are set to a blank status.</li>
<li>If in a decision period: set yourself to <code>ident</code>. (Decisions do not proceed
unless all members have the same status or <code>abstain</code>.)</li>
</ul>
</li>
<li><code>rustbot @member* irreversible ident</code> or <code>rustbot @member* immutable ident</code>
(unambiguous prefixes such as <code>immut</code> or <code>irrev</code> also work)
<ul>
<li>If not in a decision period: begin an irreversible (&quot;immutable&quot;) decision,
proposing the outcome <code>ident</code>; all other members are set to a blank status.</li>
<li>If in a decision period: set yourself to <code>ident</code>. If the decision was
previously considered reversible, change it to irreversible. The decision
now requires full team consensus. (Members may set a status of <code>abstain</code> on
the decision if they wish.)</li>
</ul>
</li>
<li><code>rustbot @member* merge</code>
<ul>
<li>Alias for <code>rustbot @member* reversible merge</code> - a reversible decision with
the proposed outcome <code>merge</code>.</li>
</ul>
</li>
<li><code>rustbot @member* close</code>
<ul>
<li>Alias for <code>rustbot @member* reversible close</code> - a reversible decision with
the proposed outcome <code>close</code>.</li>
</ul>
</li>
<li><code>rustbot @member* stabilize</code>
<ul>
<li>Alias for <code>rustbot @member* irreversible stabilize</code> - an irreversible
decision with the proposed outcome <code>stabilize</code>.</li>
</ul>
</li>
<li><code>rustbot @member* abstain</code>
<ul>
<li>If not in a decision period: error</li>
<li>If in a decision period: set your status to <code>abstain</code>. This status does not
block a decision.</li>
</ul>
</li>
<li><code>rustbot @member* hold</code>
<ul>
<li>If not in a decision period: error</li>
<li>If in a decision period: set your status to <code>hold</code>
<ul>
<li>Every N days while a hold persists, rustbot will ping all members who
have status <code>hold</code> (and potentially other involved team members as well)</li>
</ul>
</li>
</ul>
</li>
<li><code>rustbot @member* dissent</code>
<ul>
<li>Equivalent to <code>abstain</code>, except that it sets a status of <code>dissent</code>. This
status on one team member does not block a decision. A status of <code>dissent</code>
on two or more team members will block a decision.</li>
<li>Note that <code>dissent</code> should not be set when first raising a concern, only
after attempts to resolve the concern have been unsuccessful.</li>
</ul>
</li>
<li><code>rustbot restart</code>
<ul>
<li>If not in a decision period: error</li>
<li>If in a decision period: set all members other than the one issuing the
command to have a blank status. Preserve the last set status of the person
issuing the <code>restart</code>.</li>
<li>Note: if the last set status of any team members were irreversible, the
decision will continue to be treated as irreversible until all such members
set an explicit status otherwise.</li>
</ul>
</li>
<li><code>rustbot cancel</code>
<ul>
<li>If not in a decision period: error</li>
<li>If in a decision period: cancel the decision period.</li>
<li>Note that if a subsequent decision is started in the same issue, rustbot
should link to the previous decision summary table.</li>
</ul>
</li>
</ul>
<h1 id="frequently-asked-questions-2"><a class="header" href="#frequently-asked-questions-2">Frequently asked questions</a></h1>
<h2 id="why-can-members-override-other-members-positions"><a class="header" href="#why-can-members-override-other-members-positions">Why can members override other members positions?</a></h2>
<p>It's quite common to want to check boxes and similar on behalf of all the
people in a meeting. It's also annoying to have to restart a decision process
(e.g. closing and reopening with rfcbot) just to be able to close concerns on
someone else's behalf (e.g. people who have left the team, or people who raised
a concern on behalf of someone else not on the team, or similar). We can trust
each other on the team. If people abuse <code>rustbot</code> to disrupt the process, that
isn't a problem to be solved with tooling.</p>
<h2 id="do-we-want-to-require-all-but-n-people-to-affirm-a-decision-as-rfcbot-does"><a class="header" href="#do-we-want-to-require-all-but-n-people-to-affirm-a-decision-as-rfcbot-does">Do we want to require &quot;all but N&quot; people to affirm a decision, as <code>rfcbot</code> does?</a></h2>
<p>We opted to require 100% participation on irreversible decisions such as
stabilization, but not on very lightweight reversible decisions such as
starting an initiative. We believe that lang team members can be expected to at
least leave a comment (even if just <code>rustbot abstain</code>), but in the limit we
also have the option to set a status on another member's behalf.</p>
<h2 id="why-does-the-timer-start-when-the-decision-period-starts-and-not-when-a-consensus-is-reached"><a class="header" href="#why-does-the-timer-start-when-the-decision-period-starts-and-not-when-a-consensus-is-reached">Why does the timer start when the decision period <em>starts</em>, and not when a consensus is reached?</a></h2>
<p>The current <code>rfcbot</code> starts the 10 day FCP timer once a consensus is reached.
However, we have observed that, in practice, the &quot;holdouts&quot; on consensus are
typically the lang team members. Further, this seems to assume a &quot;two-phased&quot;
decision making model where folks outside the team are commenting only after
the lang team has reached a consensus. In practice, both decision-making and
commenting tend to be more fluid, and hence we would prefer not to have a long
delay after we reach consensus.</p>
<h2 id="why-not-use-checkboxes"><a class="header" href="#why-not-use-checkboxes">Why not use checkboxes?</a></h2>
<p>This process recognizes that sometimes, in the flow of conversation, the
decision to merge can transmute into a decision to close, or there may be
multiple potential outcomes.</p>
<p>The presentation of statuses also makes it easy for <code>rustbot</code> to present the
history of status changes, with links to team members' messages.</p>
<h2 id="why-is-close-always-reversible"><a class="header" href="#why-is-close-always-reversible">Why is <code>close</code> always reversible?</a></h2>
<p>Because, well, it is! We can always re-open a PR or issue, after all.</p>
<h2 id="what-about-postpone"><a class="header" href="#what-about-postpone">What about &quot;postpone&quot;?</a></h2>
<p>Just write it in the comment for a <code>@rustbot close</code>. In practice, a &quot;close&quot;
does not preclude reopening later, and a &quot;postpone&quot; does not guarantee
reopening later.</p>
<h2 id="is-dont-force-an-irreversible-decision-absolute"><a class="header" href="#is-dont-force-an-irreversible-decision-absolute">Is &quot;Don't force an irreversible decision?&quot; absolute?</a></h2>
<p>No; it's a strongly held principle, but not an absolute one. Sometimes we may
have to make an irreversible decision, even in the face of dissent. However, we
should be <em>extraordinarily</em> careful when doing so, and in particular, we should
consider very carefully whether we could make a reversible decision, or find a
better consensus, or whether the consequences of <em>not</em> making the decision
outweigh the consequences of making it. This should be an extremely rare event.</p>
<p>The previous decision-making process based on <code>rfcbot</code> allowed indefinitely
blocking concerns. This new process introduces a means of carefully resolving
such concerns, and a very careful means of proceeding <em>despite</em> such concerns
while ensuring those concerns are understood and recorded and considered.</p>
<h2 id="what-purpose-does-restart-serve"><a class="header" href="#what-purpose-does-restart-serve">What purpose does <code>restart</code> serve?</a></h2>
<p>Sometimes, a proposal has changed enough to warrant re-checking people's
positions, but has not changed enough to warrant closing it and starting the
process over. <code>restart</code> clears people's statuses to ensure that they have the
opportunity to re-confirm (or raise a hold or concern) before the decision
proceeds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chat-platform"><a class="header" href="#chat-platform">Chat platform</a></h1>
<p>The lang team hangs out in the <a href="https://forge.rust-lang.org/chat/zulip.html">rust-lang Zulip</a> in the <code>#t-lang</code>
stream. There are also other <code>#t-lang/*</code> streams that might be of
interest.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calendar"><a class="header" href="#calendar">Calendar</a></h1>
<p>We have a lang-team calendar that shows the time for our various meetings.
Meetings are generally open to anyone who wants to listen in. We also try to
post <a href="https://github.com/rust-lang/lang-team/tree/master/minutes">minutes</a> (and recordings, if any) on a &quot;best-effort&quot; basis from our
meetings.</p>
<ul>
<li><a href="https://calendar.google.com/calendar/embed?src=recud4b9o8cmc0m5rmr033p5nk%40group.calendar.google.com">View calendar</a> -- use this to view the calendar online and add it to your Google Calendar</li>
<li><a href="https://calendar.google.com/calendar/ical/recud4b9o8cmc0m5rmr033p5nk%40group.calendar.google.com/public/basic.ics">ICS file, for use outside from google calendar</a> -- you can use this to subscribe from other programs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meetings"><a class="header" href="#meetings">Meetings</a></h1>
<p>The lang team has several kinds of standing meetings.</p>
<ul>
<li><a href="./meetings/triage.html">Triage meetings</a></li>
<li><a href="./meetings/design.html">Design and planning meetings</a></li>
<li><a href="./meetings/backlog-bonanza.html">Backlog bonanza</a></li>
</ul>
<p>Unless otherwise noted, all of our meetings are open to the public for anyone to attend. You will find the timing and event details on our <a href="./calendar.html">lang team calendar</a>. We publish notes and minutes in written form in this github repository.</p>
<h2 id="recording-policy"><a class="header" href="#recording-policy">Recording policy</a></h2>
<p>Dy default, our triage and design meetings are <strong>not recorded</strong>, in order to encourage engagement from a broad audience. We may record certain design meetings, evaluated on a case-by-case basis, and only with the agreement of all participants. Any intention to record a design meeting will be established at that time that meeting is scheduled during the monthly planning meeting and included in the blog post announcing the upcoming meetings.</p>
<p>Our <a href="https://www.youtube.com/playlist?list=PL85XCvVPmGQg-gYy7R6a_Y91oQLdsbSpa">YouTube playlist</a> has recordings of some of our past meetings (along with automatically created subtitles).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="triage-meeting"><a class="header" href="#triage-meeting">Triage meeting</a></h1>
<p>The weekly triage meeting is when we go over the newly filed project
proposals along with issues that have been nominated for lang-team
feedback. We also get regular updates from the active project groups
so we can stay on top of what is going on.</p>
<h2 id="can-i-attend"><a class="header" href="#can-i-attend">Can I attend?</a></h2>
<p>Yes! The triage meeting is open to the public. You'll find the details
on our <a href="meetings/src/../../calendar.html">calendar</a>.</p>
<h2 id="how-do-i-get-something-on-the-agenda"><a class="header" href="#how-do-i-get-something-on-the-agenda">How do I get something on the agenda?</a></h2>
<p>The easiest way to get something on the agenda is to <a href="meetings/../how_to/nominate.html">nominate it</a>. The agenda is automatically built by triagebot from <a href="https://github.com/rust-lang/triagebot/blob/master/templates/lang_agenda.tt">this template</a>. We review pending <a href="meetings/../how_to/propose.html">initiative proposals</a>, <a href="meetings/../how_to/nominate.html">nominated</a> issues and PRs from a variety of repositories, as well as pending RFC requests.</p>
<h2 id="can-i-generate-the-agenda-myself"><a class="header" href="#can-i-generate-the-agenda-myself">Can I generate the agenda myself?</a></h2>
<p>Sure. You can visit the following link and one will be generated for you for (the current date):</p>
<p>https://triage.rust-lang.org/agenda/lang/triage</p>
<p>Alternatively, clone the <a href="https://github.com/rust-lang/triagebot">triagebot</a> repo and run this</p>
<pre><code class="language-bash">&gt; cargo run --bin lang agenda
</code></pre>
<p>If you install the <code>hackmd-cli</code>, you can do this:</p>
<pre><code class="language-bash">cargo run --bin lang agenda | hackmd-cli import 
</code></pre>
<h2 id="where-can-i-find-the-minutes"><a class="header" href="#where-can-i-find-the-minutes">Where can I find the minutes?</a></h2>
<p><a href="https://github.com/rust-lang/lang-team/tree/master/minutes">Triage meeting minutes are available in this directory.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-meetings"><a class="header" href="#design-meetings">Design meetings</a></h1>
<p>We reserve a weekly slot for our planning and design meetings. 
A <strong>design meeting</strong> is a one-hour deep-dive discussion into some particular
topic. Each meeting is centered around a document that is prepared for
that meeting explaining the details of what is to be discussed; we begin by reading
the document and then discussing its contents. These meetings are used for all kinds
of purposes, such as brainstorming, getting feedback on an idea, or building
consensus around a specific proposals.</p>
<h2 id="how-are-design-meetings-scheduled"><a class="header" href="#how-are-design-meetings-scheduled">How are design meetings scheduled?</a></h2>
<p>To schedule design meetings, we hold a special <strong>planning meeeting</strong> once per month.
In that meeting, we choose what design meetings we will hold the rest of the month.</p>
<p>To generate the agenda for the planning meeting, you can use the following link and then copy/paste the generated text into a fresh hackmd page:</p>
<p>https://triage.rust-lang.org/agenda/lang/planning</p>
<h2 id="how-do-i-propose-a-design-meeting"><a class="header" href="#how-do-i-propose-a-design-meeting">How do I propose a design meeting?</a></h2>
<p>You need to open an issue, <a href="meetings/../how_to/design_meeting.html">as described here</a>.</p>
<h2 id="can-i-attend-1"><a class="header" href="#can-i-attend-1">Can I attend?</a></h2>
<p>Yes! Design meetings are open to the public. You'll find the details on our <a href="meetings/../calendar.html">calendar</a>.</p>
<h2 id="how-does-a-design-meeting-work"><a class="header" href="#how-does-a-design-meeting-work">How does a design meeting work?</a></h2>
<p>Before the meeting starts, someone has to prepare a document -- we recommend using hackmd and using <a href="https://hackmd.io/VJrbVMeqT4uUDBRVncHyTw">this template</a>. </p>
<p>When the meeting starts, send out the link to your document on Zulip (and on Zoom, if you like). Everyone will start to read it. <strong>There is no expectation that people will read the document in advance.</strong></p>
<p>As they read, people will append questions to the end of the document -- the template has a space for this. We recommend making each question into a markdown section (e.g., <code>### Why is this document so great?</code>). People will append their question in that section.</p>
<p>After everyone is done reading, whoever is driving the meeting will pick questions to discuss. Typically we go in linear order but that's not required, we can go in whatever order seems best.</p>
<h2 id="where-can-i-find-the-minutes-1"><a class="header" href="#where-can-i-find-the-minutes-1">Where can I find the minutes?</a></h2>
<p>The <a href="https://github.com/rust-lang/lang-team/tree/master/design-meeting-minutes">design-meeting-minutes directory</a> contains the document from each meeting along with any questions that were asked and the ensuing disceussion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backlog-bonanza"><a class="header" href="#backlog-bonanza">Backlog bonanza</a></h1>
<p>Backlog bonanza is a particular kind of design meeting. We often schedule a backlog bonanza for those weeks where we don't have more specific things to discuss. The idea is to go through each tracking issue and &quot;disposition them&quot;. The goal is to identify what we ought to do with this particular unstable feature; e.g., what is blocking this from being stabilized? Do we still want this? Is it perma-unstable?</p>
<h2 id="when-does-backlog-bonanza-take-place"><a class="header" href="#when-does-backlog-bonanza-take-place">When does backlog bonanza take place?</a></h2>
<p>Backlog bonanza meetings are typically scheduled as <a href="meetings/design.html">design meetings</a>.</p>
<h2 id="can-i-attend-2"><a class="header" href="#can-i-attend-2">Can I attend?</a></h2>
<p>Yes! Design meetings are open to the public. You'll find the details on our <a href="meetings/../calendar.html">calendar</a>.</p>
<h2 id="what-labels-do-we-apply-to-issues"><a class="header" href="#what-labels-do-we-apply-to-issues">What labels do we apply to issues?</a></h2>
<p>Here are the labels we apply during the process and their meaning:</p>
<ul>
<li>S-tracking-ready-to-stabilize: Needs a stabilization PR (good to go :train:)</li>
<li>S-tracking-needs-to-bake: Needs time to bake (set a date? other criteria?)</li>
<li>S-tracking-impl-incomplete: Not code complete or blocking bugs</li>
<li>S-tracking-unimplemented: Implementation not begun</li>
<li>S-tracking-design-concerns: Blocking design concerns
<ul>
<li>This might be &quot;doesn't quite seem to deliver value we hoped for&quot; or &quot;something doesn't feel right&quot;</li>
</ul>
</li>
<li>S-tracking-perma-unstable
<ul>
<li>Internal implementation detail of rustc, stdlib</li>
</ul>
</li>
<li>S-tracking-needs-investigation</li>
</ul>
<h2 id="where-can-i-find-the-minutes-2"><a class="header" href="#where-can-i-find-the-minutes-2">Where can I find the minutes?</a></h2>
<p>Currently the minutes are tracked in the issues themselves, but we also create hackmd documents in the <a href="https://hackmd.io/team/rust-lang-team?nav=overview">Rust lang team</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This section contains &quot;notes&quot; about the design of various proposals.
These are often just links to conversations, along with a few key
ideas and summaries. Sometimes it includes other information, such as
lang-team decisions about whether a particular proposal is viable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="can-we-allow-integer-literals-like-1-to-be-inferred-to-floating-point-type"><a class="header" href="#can-we-allow-integer-literals-like-1-to-be-inferred-to-floating-point-type">Can we allow integer literals like <code>1</code> to be inferred to floating point type?</a></h1>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>In rust today, an integer like <code>1</code> cannot be inferred to floating
point type. This means that valid-looking numeric expressions like
<code>22.5 + 1</code> will not compile, and one must instead write <code>22.5 + 1.0</code>. Can/should we change this?</p>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>This was discussed on Zulip in <a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html">May 2020</a>. Some of the key highlights from the discussion were:</p>
<ul>
<li>Floating point literals are prone to many surprises that integers
are not. For <a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html#196887384">example</a>, <code>20_000_000 + 1</code>, if inferred to <code>f32</code>
type, would have the final value <code>20_000_000.0</code>. This leads some to
conclude that <a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html#196887384">&quot;the surprise factor of floats is so high that they
are qualitatively different than integers&quot;</a>.</li>
<li>But there are a lot of similar surprising things:
<ul>
<li><a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html#196930252"><code>20_000_001_f32</code>, for example, is also going to be <code>20_000_000</code>.</a></li>
<li>Integer overflow can mean that <code>255 + 1</code> has the value 0.</li>
</ul>
</li>
<li>Some key questions to consider:
<ul>
<li><a href="https://zulip-archive.rust-lang.org/213817tlang/43153EditionRequestlet1beafloatliteral.html#196926142">How often does adding <code>.0</code> result in some insight?</a></li>
<li>How much would <em>seeing</em> the <code>.0</code> help to debug a tricky problem?</li>
</ul>
</li>
<li>Balanced against the annoyance and surprise factor.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generalized-coroutines"><a class="header" href="#generalized-coroutines">Generalized coroutines</a></h1>
<p>Since even before Rust 1.0, users have desired the ability to <code>yield</code> like in
other languages. The compiler infrastructure to achieve this, along with an
unstable syntax, have existed for a while now. But despite <em>a lot</em> of debate,
we've failed to polish the feature up enough to stabilize it. I've tried to
write up a summary of the different design considerations and the past debate
around them below:</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<ul>
<li>The distinction between a &quot;coroutine&quot; and a &quot;generator&quot; can be a bit vague,
varying from one discussion to the next.</li>
<li>In these notes a generator is anything which <em>directly</em> implements <code>Iterator</code>
or <code>Stream</code> while a coroutine is anything which can take arbitrary input,
yield arbitrary output, and later resume execution at the previous yield.</li>
<li>Thus, the &quot;generator&quot; syntax proposed in <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> and currently
implemented behind the &quot;generator&quot; feature is actually a coroutine syntax for
the sake of these notes, <em>not a true generator</em>.
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2996/">RFC-2996</a> defines a true generator syntax in &quot;future additions&quot;.</li>
</ul>
</li>
<li>Note also that &quot;coroutines&quot; here are really &quot;semicoroutines&quot; since they can
only yield back to their caller.</li>
<li>I will continue to group the <a href="https://github.com/rust-lang/rfcs/pull/2033">original eRFC text</a> and the later <a href="https://github.com/rust-lang/rust/pull/68524">generator
resume arguments</a> extension
togther as &quot;<a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a>&quot;. That way I only have 3 big proposals to deal
with.</li>
<li>In rustc, a coroutine's &quot;witness&quot; is the space where stack-allocated values
are stored if needed across yields. I'm borrowing this terminology here. Any
such cross-yield bindings are said to be &quot;witnessed&quot;.</li>
</ul>
<pre><code class="language-rust ignore">// This is an example coroutine which might assist a streaming base64 encoder
|sextet, octets| {
    let a = sextet; // witness a, b, and c sextets for later use
    yield;
    let b = sextet;
    octets.push(a &lt;&lt; 2 | b &gt;&gt; 4); // aaaaaabb
    yield;
    let c = sextet;
    octets.push((b &amp; 0b1111) &lt;&lt; 4 | c &gt;&gt; 2); // bbbbcccc
    yield;
    octets.push((c &amp; 0b11) &lt;&lt; 6 | sextet) // ccdddddd
}

// This is an example generator which might be used in Iterator::flat_map.
gen {
  for item in inner {
    for mapped in func(item) {
      yield mapped;
    }
  }
}

// This is an example async generator which might be used in Stream::and_then
async gen {
  while let Some(item) = inner.next().await {
    yield func(item).await;
  }
}
</code></pre>
<h2 id="coroutine-trait"><a class="header" href="#coroutine-trait">Coroutine trait</a></h2>
<ul>
<li>The coroutine syntax must produce implementations of some trait.</li>
<li><a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> and <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> propose the <code>Generator</code> trait.</li>
<li>Note that Rust's coroutines and subroutines look the same from the outside:
take input, mutate state, produce output.</li>
<li>Thus, <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> proposes using the <code>Fn*</code> traits instead, including a new
<code>FnPin</code> for immovable coroutines.
<ul>
<li>Hierarchy: <code>Fn</code> is <code>FnMut + Unpin</code> is <code>FnPin</code> is <code>FnOnce</code>.
<ul>
<li>May not be <em>required</em> at the trait level (someone may someday find a use
to implementing <code>FnMut + !FnPin</code>) but all closures implement the traits in
this order.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="coroutine-syntax"><a class="header" href="#coroutine-syntax">Coroutine syntax</a></h2>
<ul>
<li>The closure syntax is reused for coroutines by <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a>, <a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a>,
and <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a>.</li>
<li>Commentators have suggested that the differences between coroutines and
closures under <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> and <a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> justify an entirely distinct
syntax to reduce confusion.</li>
<li><a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> fully reuses the <em>semantics</em> of closures, greatly simplifying the
design space and making the shared syntax obvious.</li>
</ul>
<h2 id="taking-input"><a class="header" href="#taking-input">Taking input</a></h2>
<ul>
<li>The major disagreement between past proposals is whether to use &quot;yield
expressions&quot; or &quot;magic mutation&quot;.
<ul>
<li>Yield expression: <code>let after = yield output;</code>
<ul>
<li>Used by <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a></li>
</ul>
</li>
<li>Magic mutation: <code>let before = arg; yield output; let after = arg;</code>
<ul>
<li>Used by <a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> and <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a></li>
</ul>
</li>
</ul>
</li>
<li>Many people have a strong gut preference for yield expressions.
<ul>
<li>In simple cases, Rust generally prefers to produce values as output from
expressions rather than by mutation of state. &quot;Yield expressions <em>feel</em> more
Rusty.&quot;</li>
<li>However, magic mutation is likely correct, even though at first glance it
feels surprising. In addition to reasons below, holding references to past
resume args is rare, often a logic error. Rust can use mutation checks to
catch and give feedback.</li>
</ul>
</li>
<li>&quot;Magic mutation&quot; is a bit of a misnomer. The resume argument values are <em>not
themselves being mutated.</em> The argument bindings are simply being reassigned
across yields.
<ul>
<li>In a sense, argument bindings are reassigned in the exact same way across
returns.</li>
<li>Previous arguments (if unmoved) are dropped prior to yielding and are
reassigned after resuming.</li>
<li>People will get yelled at by the borrow checker if they try to hold borrows
of arguments across yields. But the fix is generally easy: move the argument
to a new binding before yielding.</li>
</ul>
</li>
</ul>
<pre><code class="language-text">=&gt; |x| {
    let y = &amp;x;
    yield;
    dbg!(y, x);
}

error[E0506]: cannot pass new `x` because it is borrowed
 --&gt; src/lib.rs:3:4
  |
2 |     let y = &amp;x;
  |             -- borrow of `x` occurs here
3 |     yield;
  |     ^^^^^ assignment to borrowed `x` occurs here
4 |     dbg!(y, x);
  |             - borrow later used here
  |
  = help: consider moving `x` into a new binding before borrowing

=&gt; |x| {
    let a = x;
    let y = &amp;a;
    yield;
    dbg!(y, x);
}
</code></pre>
<ul>
<li>Magic mutation could be replaced by &quot;magic shadowing&quot; where new arguments
shadow old ones at yield in order to allow easy borrowing of past argument
values. But this is a huge footgun. See if you can spot the issue with the
following code if <code>ctx</code> shadows its past value rather than overwriting it:</li>
</ul>
<pre><code class="language-rust ignore">std::future::from_fn(|ctx| {
  if is_blocked() {
    register_waker(ctx);
    yield Pending;
  }

  while let Pending = task.poll(ctx) { .. }
})
</code></pre>
<ul>
<li>&quot;Yield expression&quot; causes problems with first-resume input.
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> passes the first resume argument via a closure parameters
while later arguments are produced by <code>yield</code> expressions.</li>
<li>This part of why it is so hard to unify generalized coroutines with a
generator syntax like <code>gen { }</code> or <code>gen fn</code>. Where does the first input go?
Where do you annotate the argument type even?</li>
</ul>
</li>
<li>To increase clarity, users almost always want resume arguments to be named.
<ul>
<li>With magic mutation, all resume arguments are already named since they reuse
the closures arguments on every resume. Any unmoved arguments are dropped
just prior to yielding, so they are not witnessed and do not increase the
coroutine size.
<ul>
<li>Also get multiple arguments for free if using the <code>Fn*</code> traits.</li>
</ul>
</li>
<li>Yield expressions require users to repeatedly assign resume arguments to
named bindings manually. Such bindings must be included in the closure state
if they have any drop logic.</li>
</ul>
</li>
</ul>
<h2 id="borrowed-resume-arguments"><a class="header" href="#borrowed-resume-arguments">Borrowed resume arguments</a></h2>
<ul>
<li>What happens when a coroutine witnesses a borrow passed as a resume argument?
For example:</li>
</ul>
<pre><code class="language-rust ignore">let co = |x: &amp;i32| {
  let mut values = Vec::new();
  loop {
    values.push(x);
    yield;
  }
};

// potentially ok:
let mut x = 0;
co(&amp;x);

// must not be allowed:
x = 1;
co(&amp;x);
</code></pre>
<ul>
<li>As of writing, <a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> leaves this as an unresolved question with a note
to potentially restrict resume arguments to being <code>'static</code>.</li>
<li>Since coroutines under <a href="https://github.com/rust-lang/rfcs/pull/2781">MCP-49</a> act as much like closures as possible, and
treat the witness and capture data the same whenever possible, the example
above would fail in a similar way to the example below, giving a &quot;borrowed
data escapes into closure state&quot; error or similar even if <code>x</code> is not mutated.</li>
</ul>
<pre><code class="language-rust ignore">let mut values = Vec::new();
|x: &amp;i32| {
  loop {
    values.push(x);
//  ^^^^^^^^^^^^^^ `x` escapes the closure body here
    yield;
  }
}
</code></pre>
<ul>
<li>As of writing, <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> appears to take a similar approach (although the
error message is not super descriptive).</li>
<li>Ideally someday we'd do something nicer but any such solution would apply to both captured state and witnessed state in the same way.</li>
</ul>
<h2 id="lending"><a class="header" href="#lending">Lending</a></h2>
<ul>
<li>Coroutines would eventually like to yield borrows of state to the caller. This
is &quot;lending&quot; coroutine (sometimes also called an &quot;attached&quot; coroutine).</li>
<li>Using <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a>, a lending coroutine might look like:</li>
</ul>
<pre><code class="language-rust ignore">|| {
  let mut buffer = Vec::new();
  loop {
    let n = fill_buffer(&amp;mut buffer);
    yield &amp;buffer[..n];
  }
}
</code></pre>
<ul>
<li>None of the major proposals have made an effort to resolve this directly as
far as I am aware.
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2996/">RFC-2996</a> gets the closest with a mention of <code>LendingStream</code> and
<code>LendingIterator</code> traits in &quot;future additions&quot;.</li>
<li>We should probably get some experience with lending traits at the lib level
before attempting to add language level support.</li>
</ul>
</li>
<li>If lending closures were implemented, <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> could immediately be used to
build lending streams, iterators, etc so long as the respective traits have
the needed GAT-ification.</li>
</ul>
<h2 id="enum-wrapping"><a class="header" href="#enum-wrapping">Enum-wrapping</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> and <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> propose that <code>yield x</code> should produce
<code>GeneratorState::Yielded(x)</code> or equivalent as an output, in order to
discriminate between yielded and returned values.</li>
<li><a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> instead gives <code>yield x</code> and <code>return x</code> nearly identical semantics
and output <code>x</code> directly, so the two must return the same type.</li>
<li>Enum-wrapping here is analogous to Ok-wrapping elsewhere. Similar debates
result.</li>
<li>When using enum-wrapping, the syntax to specify distinct return/yield types is
hotly debated.</li>
<li>Generators always want return and yield to have different types (<code>()</code> vs <code>T</code>)
but a generator syntax on top of coroutines could be used to auto-insert enum
wrappers around yield vs return arguments.</li>
<li>Auto-enum-wrapping can slightly improve type safety in some cases where
<code>return</code> should be treated specially to avoid bugs.</li>
<li>No-enum-wrapping when combined with the <code>impl Fn*</code> choice of trait, allow
the coroutine syntax to be used directly with existing higher-order methods
on iterator, stream, collection types, async traits, etc.</li>
<li>Note these two approaches are &quot;isomorphic&quot;: a coroutine that returns
<code>GeneratorState&lt;T, T&gt;</code> could be wrapped to return <code>T</code> by some sort of
combinator and a coroutine that only returns <code>T</code> can have <code>yield</code> and <code>return</code>
values manually wrapped in <code>GeneratorState</code>. This is just about ergonomics:</li>
</ul>
<pre><code class="language-rust ignore">// Without enum wrapping:
std::iter::from_fn(|| {
  yield Some(1);
  yield Some(2);
  yield Some(3);
  None
}).map(|x| {
  yield -x;
  yield x;
});

// With enum wrapping:
std::iter::from_gen_fn(|| {
  yield 1;
  yield 2;
  yield 3;
}).map(unwrap_gen_state(|x| {
  yield -x;
  yield x;
}));

// Needed for un-enum-wrapping when not desired.
// Could be replaced by sufficiently fancy !-casting?
fn unwrap_gen_state&lt;T&gt;(f: impl FnMut() -&gt; GeneratorState&lt;T, !&gt;) -&gt; T { ... }
fn merge_gen_state&lt;T&gt;(f: impl FnMut() -&gt; GeneratorState&lt;T, T&gt;) -&gt; T { ... }

// With no wrapping + generators:
(gen {
  yield 1;
  yield 2;
  yield 3;
}).map(|x| {
  yield -x;
  yield x;
})
</code></pre>
<h2 id="movability"><a class="header" href="#movability">Movability</a></h2>
<ul>
<li>All proposals want movability/<code>impl Unpin</code> to be inferred.
<ul>
<li>If we forbid &quot;borrowed data escaping into closure state&quot;, the inference
rules should be relatively simple: witnessing any borrow triggers
immovability.
<ul>
<li>Dead borrows should not be witnessed.</li>
</ul>
</li>
<li>But exact inference rules may only be well understood after an attempt at
implementation.</li>
</ul>
</li>
<li>Soundness of <code>pin_mut!</code> is a little tricky but seems to be fine no matter what.
<ul>
<li>If the resulting mutable borrow is witnessed ⇒ coroutine is <code>!Unpin</code> because
of inference rules</li>
<li>If the pinned data is <code>!Unpin</code> and is witnessed ⇒ coroutine is <code>!Unpin</code>
because witness contains <code>!Unpin</code> data</li>
<li>Thus, if the coroutine can be moved after resume, any data stack-pinned
(really witness-pinned) by <code>pin_mut!</code> is not referenced and is <code>Unpin</code>.</li>
</ul>
</li>
<li>Until inference is solved, the <code>static</code> keyword can be used as a modifier.</li>
</ul>
<pre><code class="language-rust ignore">// movable via inference
|| {
  let x = 4;
  let y = &amp;x;
  dbg!(y);
  yield;
}

// guaranteed movable (pending inference)
static || {
  ...
}

// immovable
|| {
  let x = 4;
  let y = &amp;x;
  yield;
  dbg!(y);
}
</code></pre>
<h2 id="once-coroutines"><a class="header" href="#once-coroutines">&quot;Once&quot; coroutines</a></h2>
<ul>
<li>A lot of coroutines destroy captured data when run.</li>
<li>These coroutines (notably futures) can be resumed many times but can only be
run through &quot;once&quot;.</li>
<li>In contrast to non-yield <code>FnOnce</code> closures, this can not be solved at the type
level because a coroutine can run out after an arbitrary, runtime-dependent
number of resumptions.
<ul>
<li>Attempts to discriminate with enums tend to run up against <code>Pin</code>.</li>
</ul>
</li>
<li>Coroutines must have the ability to block restart with a <code>panic!</code>.
<ul>
<li>Following <code>return</code>.</li>
<li>Following <code>panic!</code> and recovery.</li>
<li>The term &quot;poison state&quot; technically refers to only the later case. But here
I will use it to mean any state at which the closure panics if resumed.</li>
</ul>
</li>
<li><a href="https://github.com/rust-lang/rfcs/pull/2781">RFC-2781</a> and <a href="https://github.com/rust-lang/rfcs/pull/2033">eRFC-2033</a> propose that all coroutines become poisoned
after returning.</li>
<li><a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> recommends that all non-capture-destroying coroutines resume at
their initial state after returning.
<ul>
<li>This can be very handy in some situations. In fact, I use it several times
in examples to increase readability. See anywhere I <code>iter.map(coroutine)</code> or
the base64 encoder.</li>
<li>Similar question around generators: should they loop to save on a state or
should they be fused-by-default?</li>
<li>If we do decide to panic-after-return, restart-after-return can still be
emulated using <code>loop { .. }</code> as the coroutine body instead of simply <code>{ .. }</code>. This is even zero-cost because unreachable poison states are eliminated.</li>
</ul>
</li>
<li><a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> also optionally proposes that capture-destroying closures should
only implement <code>FnOnce</code> unless explicitly annotated, even if they should
apparently be resumable several times.
<ul>
<li><code>mut || { drop(capture); }</code> is recommended as the modifier, to hint that an
<code>FnMut</code> impl is being requested when the closure in question would otherwise
impl only <code>FnOnce</code>.</li>
<li>But the behavior of this modifier is probably too obscure and requires
too much explanation vs &quot;closures always impl FnMut/FnPin if they contain
yield&quot;.</li>
</ul>
</li>
</ul>
<h2 id="async-coroutines"><a class="header" href="#async-coroutines">Async coroutines</a></h2>
<ul>
<li>I am aware of no strong proposal for an async version of generalized
coroutines although a fair amount of discussion has taken place.
<ul>
<li>In the context of <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a>, how should <code>async || { ... yield ...}</code> be
handled in the very long-term? <em>Error right now.</em></li>
</ul>
</li>
<li>Async coroutines don't make much sense because of resume arguments. Async
functions are already coroutines which take an <code>&amp;mut Context</code> as a resume
argument. How should additional arguments should be specified?
<ul>
<li>Do the additional args need to be passed every single poll or are they only
needed when resuming after <code>Ready</code>?</li>
<li>If they are stored between <code>Ready</code>s, how does that interact with the ban on
witnessing external borrows? Badly.</li>
<li>On resume, the the coroutine might only take the additional arguments. It
could then yield a future to take the async context and handle any <code>Pending</code>
yields.</li>
<li>If so, how is the coroutine body broken up into distinct futures to be
yielded?</li>
<li>What happens if a yielded future is destroyed early? Panic on resume?</li>
</ul>
</li>
<li>Generators and async are both sugars on top of coroutines and are orthogonal
to each other. But neither is orthogonal to the underlying coroutine feature:</li>
</ul>
<pre><code class="language-rust ignore">// an async block
async {
  &quot;hello&quot;
}

// an async generator
async gen {
  yield &quot;hello&quot;;
}

// an &quot;async coroutine&quot;
|ctx: &amp;mut Context| {
  yield Poll::Ready(&quot;hello&quot;);
}
</code></pre>
<ul>
<li>Taking the async context explicitly makes it cleaner to implement some complex
async functions which take additional poll parameters.
<ul>
<li>An <code>await_with!</code> macro would be quite useful for implementing <code>await</code> loops
on arbitrary <code>Poll</code>-returning functions.
<ul>
<li>Would be a good candidate for an <code>.await(args..)</code> syntax if very heavily
used.</li>
</ul>
</li>
<li>For example, an simple little checksumming async write wrapper might look
like this:</li>
</ul>
</li>
</ul>
<pre><code class="language-rust ignore">|ctx: &amp;mut Context, bytes: &amp;[u8]| -&gt; Poll&lt;usize&gt; {
  let mut checksum = 0;
  let mut count = 0;
  pin_mut!(writer);

  loop {
    let n = 4096 - count;
    if n == 0 {
      await_with!(writer.poll_write, ctx, &amp;[checksum]);
    }

    let part = &amp;bytes[..bytes.len().min(n)];
    checksum = part.fold(checksum, |x, &amp;y| x ^ y);
    await_with!(writer.poll_write, ctx, part);

    count += part.len();
    yield Ready(part.len());
  }
}
</code></pre>
<h2 id="try"><a class="header" href="#try">Try</a></h2>
<ul>
<li>All proposals work fine with the <code>?</code> operator without even trying (haha).</li>
<li><code>Poll&lt;Result&lt;_, _&gt;&gt;</code> and <code>Poll&lt;Option&lt;Result&lt;_, _&gt;&gt;&gt;</code> already implement <code>Try</code>!</li>
<li>Generators usually want a totally different <code>?</code> desugar that does <code>yield Some(Err(...)); return None;</code> instead of <code>return Err(...)</code>.
<ul>
<li>This comes up a lot in discussions of general coroutine syntaxes but just
muddies things up because (say it with me) generators ≠ coroutines.</li>
<li>Sugar-free implementation is easy: <code>yield Some(try { ... }); None</code></li>
</ul>
</li>
<li>Try blocks in general are super useful for handing errors by moving into
specific error-handeling states.</li>
</ul>
<h2 id="language-similarity"><a class="header" href="#language-similarity">Language similarity</a></h2>
<ul>
<li>Rust's version of coroutines can be a bit unusual compared to other languages.
But the reason for this is simple: you need arguments to resume Rusty
coroutines.</li>
<li>Resume arguments in other languages can be passed just fine by sharing mutable
data. So all they need to implement are generators, not true coroutines as
defined here.</li>
</ul>
<pre><code class="language-python"># Generator function takes a word list and name on construction.
# The shared list is mutated to make room for new words.
def write_greeting(name, words):
    words.append('hello')
    if words.is_full:
        yield
    words.append(name)

</code></pre>
<pre><code class="language-rust ignore">// Function only needs name to construct coroutine.
// Coroutine gets mutable access to the word list each resume.
fn write_greeting(name: String) -&gt; impl FnMut(&amp;mut Vec&lt;String&gt;) {
  |words| {
    words.push(&quot;hello&quot;.to_string());
    if words.len() == words.capacity() {
      yield
    }
    words.push(name);
  }
}

</code></pre>
<h2 id="language-complexity"><a class="header" href="#language-complexity">Language complexity</a></h2>
<ul>
<li>The main selling point of <a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a> is that it avoids adding a whole new language feature with associated design questions. Instead, the common answer to questions regarding MCP-49 is that yield-closures simply do whatever closures do.
<ul>
<li>The syntax is the same.</li>
<li>Captures work the same way.</li>
<li>Arguments are passed the same way.</li>
<li>Return and yield both drop the latest arguments and then pop the call stack.</li>
<li>The only big difference is that once <code>yield</code> is involved, some variables get
stored in a witness struct rather than in the stack frame. Plus the need for
a poison state.</li>
</ul>
</li>
<li>In fact, <code>return</code> behaves exactly like a simultaneous <code>yield</code> + <code>break 'closure_body</code>.
<ul>
<li>In a sense, every closure already has a single yield point at which it
resumes after <code>return</code>.</li>
<li>A <code>yield</code> adds a second resume point: hence the need for a discriminant.</li>
</ul>
</li>
<li>Under that proposal, anywhere a closure can be used, a coroutine can too. And
vice versa.</li>
</ul>
<h2 id="generator-unification"><a class="header" href="#generator-unification">Generator unification</a></h2>
<ul>
<li>So far in this proposal, I've been very careful to distinguish generators (as
supported by the propane and async_stream crates, proposed by <a href="https://github.com/rust-lang/rfcs/pull/2996/">RFC-2996</a>,
etc) from the coroutines discussed here. They are treated as two separate
language features.</li>
<li>Does Rust have &quot;room&quot; for both stream syntax and a generator syntax? Would it
be better to find a single solution to both?</li>
<li>A single solution is difficult for a few reasons:
<ul>
<li>Taking resume arguments muddies the syntax. For example, what would be the
syntax for a generator function which takes an explicit resume argument?</li>
<li>The closure syntax works great for coroutines which implement <code>Fn*</code> a la
<a href="https://github.com/rust-lang/lang-team/issues/49">MCP-49</a>! But reusing that syntax to magically implement <code>Iterator</code> or
<code>Stream</code> would cause confusion.</li>
<li>On that note, generators <em>definitely</em> want to implement different traits vs
coroutines. <code>Iterator</code> and <code>Stream</code> rather than <code>Fn</code> or (ironically)
<code>Generator</code>.</li>
<li>As stated above, async coroutines don't make much sense: async interacts
poorly with resume arguments.</li>
<li>Async generators are super important, don't care about resume arguments.</li>
<li>As mentioned in the section on try, generators and coroutines generally want
different error handling. Or at lest, some more complex <code>?</code> desugar is not
so obvious for coroutines in general as it is for generators specifically.</li>
</ul>
</li>
<li>Once generalized coroutines are in place, a generator syntax like the one in
<a href="https://github.com/rust-lang/rfcs/pull/2996/">RFC-2996</a> is a trivial sugar on top:</li>
</ul>
<pre><code class="language-rust ignore">gen {
  for item in inner {
    for mapped in func(item) {
      yield mapped;
    }
  }
}

// becomes

std::iter::from_fn(|| {
  for item in inner {
    for mapped in func(item) {
      yield Some(mapped);
    }
  }
  None
})
</code></pre>
<pre><code class="language-rust ignore">async gen {
  while let Some(item) = inner.next().await {
    yield func(item).await;
  }
}

// becomes

std::stream::from_fn(|ctx| {
  while let Some(item) = await_with!(inner.next(), ctx) {
    yield Ready(Some(await_with!(func(item), ctx)));
  }
  Ready(None)
})
</code></pre>
<ul>
<li>Proc-macro crates could provide very satisfactory <code>gen</code> and <code>gen_async</code> macros
until we are sure of the need to support such a sugar directly in language as
a keyword or in core as a first-party macro.</li>
</ul>
<h2 id="past-discussions"><a class="header" href="#past-discussions">Past discussions</a></h2>
<p>There are a <em>lot</em> of these. Dozens of internals threads, reddit posts, blog
posts, draft RFCs, pre RFCs, actual RFCs, who knows what in Zulip, and so on.
So this isn't remotely exhaustive:</p>
<ul>
<li>https://github.com/CAD97/rust-rfcs/pull/1</li>
<li>https://github.com/rust-lang/lang-team/issues/49</li>
<li>https://github.com/rust-lang/rfcs/pull/2033</li>
<li>https://github.com/rust-lang/rfcs/pull/2781</li>
<li>https://github.com/rust-lang/rust/issues/43122</li>
<li>https://github.com/rust-lang/rust/pull/68524</li>
<li>https://internals.rust-lang.org/t/crazy-idea-coroutine-closures/1576</li>
<li>https://internals.rust-lang.org/t/no-return-for-generators/11138</li>
<li>https://internals.rust-lang.org/t/syntax-for-generators-with-resume-arguments/11456</li>
<li>https://internals.rust-lang.org/t/trait-generator-vs-trait-fnpin/10411</li>
<li>https://reddit.com/r/rust/comments/dvd3az/generalizing_coroutines/</li>
<li>https://samsartor.com/coroutines-2</li>
<li>https://smallcultfollowing.com/babysteps/blog/2020/03/10/async-interview-7-withoutboats/#async-fn-are-implemented-using-a-more-general-generator-mechanism</li>
<li>https://users.rust-lang.org/t/coroutines-and-rust/9058</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extending-the-capabilities-of-compiler-generated-function-types"><a class="header" href="#extending-the-capabilities-of-compiler-generated-function-types">Extending the capabilities of compiler-generated function types</a></h1>
<h2 id="background-1"><a class="header" href="#background-1">Background</a></h2>
<p>Both standalone functions and closures have unique compiler-generated types.
The rest of this document will refer to both categories as simply &quot;function
types&quot;, and will use the phrase &quot;function types without upvars&quot; to refer to
standalone functions <em>and</em> closures without upvars.</p>
<p>Today, these function types have a small set of capabilities, which are
exposed via trait implementations and implicit conversions.</p>
<ul>
<li>
<p>The <code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code> traits are implemented based on the way
in which upvars are used.</p>
</li>
<li>
<p><code>Copy</code> and <code>Clone</code> traits are implemented when all upvars implement the
same trait (trivially true for function types without upvars).</p>
</li>
<li>
<p><code>auto</code> traits are implemented when all upvars implement the same trait.</p>
</li>
<li>
<p>Function types without upvars have an implicit conversion to the
corresponding <em>function pointer</em> type.</p>
</li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>There are several cases where it is necessary to write a <a href="https://en.wikipedia.org/wiki/Trampoline_(computing)">trampoline</a>. A trampoline
is a (usually short) generic function that is used to adapt another function
in some way.</p>
<p>Trampolines have the caveat that they must be standalone functions. They cannot
capture any environment, as it is often necessary to convert them into a
function pointer.</p>
<p>Trampolines are most commonly used by compilers themselves. For example, when a
<code>dyn Trait</code> method is called, the corresponding vtable pointer might refer
to a trampoline rather than the original method in order to first down-cast
the <code>self</code> type to a concrete type.</p>
<p>However, trampolines can also be useful in low-level code that needs to interface
with C libraries, or even in higher level libraries that can use trampolines in
order to simplify their public-facing API without incurring a performance
penalty.</p>
<p>By expanding the capabilities of compiler-generated function types it would
be possible to write trampolines using only safe code.</p>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>The goal of this design note is describe a range of techniques for implementing
<em>trampolines</em> (defined below) and some of the feedback regarding those solutions.
This design note does not intend to favor any specific solutions, just reflect past
discussions. The presence or absence of any particular feedback in this document
does not necessarily serve to favor or disfavor any particular solution.</p>
<h2 id="history-1"><a class="header" href="#history-1">History</a></h2>
<p>Several mechanisms have been proposed to allow trampolines to be written in safe
code. These have been discussed at length in the following places.</p>
<p>PR adding <code>Default</code> implementation to function types:</p>
<ul>
<li>https://github.com/rust-lang/rust/pull/77688</li>
</ul>
<p>Lang team triage meeting discussions:</p>
<ul>
<li>https://youtu.be/NDeAH3woda8?t=2224</li>
<li>https://youtu.be/64_cy5BayLo?t=2028</li>
<li>https://youtu.be/t3-tF6cRZWw?t=1186</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<h3 id="an-adaptor-which-prevents-unwinding-into-c-code"><a class="header" href="#an-adaptor-which-prevents-unwinding-into-c-code">An adaptor which prevents unwinding into C code</a></h3>
<p>In this example, we are building a crate which provies a safe wrapper around
an underlying C API. The C API contains at least one function which accepts
a function pointer to be used as a callback:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod c_api {
    extern {
        pub fn call_me_back(f: extern &quot;C&quot; fn());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We would like to allow users of our crate to safely use their own callbacks.
The problem is that if the callback panics, we would unwind into C code and this
would be undefined behaviour.</p>
<p>To avoid this, we would like to interpose between the user-provided callback and
the C API, by wrapping it in a call to <code>catch_unwind</code>. Unfortunately, the C API
offers no way to pass an additional &quot;custom data&quot; field that we could use to
store the original function pointer.</p>
<p>Instead, we could write a generic function like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{panic, process};

pub fn call_me_back_safely&lt;F: Fn() + Default&gt;(_f: F) {
    extern &quot;C&quot; fn catch_unwind_wrapper&lt;F: Fn() + Default&gt;() {
        if panic::catch_unwind(|| {
            let f = F::default();
            f()
        }).is_err() {
            process::abort();
        }
    }
    unsafe {
        c_api::call_me_back(catch_unwind_wrapper::&lt;F&gt;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This compiles, and is intended to be used like so:</p>
<pre><pre class="playground"><code class="language-rust">fn my_callback() {
    println!(&quot;I was called!&quot;)
}

fn main() {
    call_me_back_safely(my_callback);
}
</code></pre></pre>
<p>However, this will fail to compile with the following error:</p>
<blockquote>
<p>error[E0277]: the trait bound <code>fn() {my_callback}: Default</code> is not satisfied</p>
</blockquote>
<h2 id="implementing-the-default-trait"><a class="header" href="#implementing-the-default-trait">Implementing the <code>Default</code> trait</a></h2>
<p>The solution initially proposed was to implement <code>Default</code> for function types
without upvars. Safe trampolines would be written like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_one_adapter&lt;F: Fn(i32) + Default&gt;(arg: i32) {
    let f = F::default();
    f(arg + 1);
}
<span class="boring">}
</span></code></pre></pre>
<p>Discussions of this design had a few central themes.</p>
<h3 id="when-should-default-be-implemented"><a class="header" href="#when-should-default-be-implemented">When should <code>Default</code> be implemented?</a></h3>
<p>Unlike <code>Clone</code>, it intuitively does not make sense for a closure to implement
<code>Default</code> just because its upvars are themselves <code>Default</code>. A closure like
the following might not expect to ever observe an ID of zero:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_thing() -&gt; impl FnOnce() {
    let id: i32 = generate_id();
    || {
      do_something_with_id(id)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The closure may have certain pre-conditions on its upvars that are violated
by code using the <code>Default</code> implementation. That said, if a function type has
no upvars, then there are no pre-conditions to be violated.</p>
<p>The general consensus was that if function types are to implement <code>Default</code>,
it should only be for those without upvars.</p>
<p>However, this point was also used as an argument against implementing
<code>Default</code>: traits like <code>Clone</code> are implemented structurally based on the
upvars, whereas this would be a deviation from that norm.</p>
<h3 id="leaking-details--weakening-privacy-concerns"><a class="header" href="#leaking-details--weakening-privacy-concerns">Leaking details / weakening privacy concerns</a></h3>
<p>Anyone who can observe a function type, and can also make use of the <code>Default</code>
bound, would be able to safely call that function. The concern is that this
may go against the intention of the function author, who did not explicitly
opt-in to the <code>Default</code> trait implementation for their function type.</p>
<p>Points against this argument:</p>
<ul>
<li>
<p>We already leak this kind of capability with the <code>Clone</code> trait implementation.
A function author may write a <code>FnOnce</code> closure and rely on it only being callable once. However, if the upvars are all <code>Clone</code> then the function itself can be
cloned and called multiple times.</p>
</li>
<li>
<p>It is difficult to construct practical examples of this happening. The leakage
happens in the wrong direction (upstream) to be easily exploited whereas we
usually care about what is public to downstream crates.</p>
<p>Without specialization, the <code>Default</code> bound would have to be explicitly listed
which would then be readily visible to consumers of the upstream code.</p>
</li>
<li>
<p>Features like <code>impl Trait</code> make it relatively easy to avoid leaking this
capability when it's not wanted.</p>
</li>
</ul>
<p>Points for this argument:</p>
<ul>
<li>The <code>Clone</code> trait requires an existing instance of the function in order to be
exploited. The fact that the <code>Default</code> trait gives this capability to types
directly makes it sufficiently different from <code>Clone</code> to warrant a different
decision.</li>
</ul>
<p>These discussions also raise the question of whether the <code>Clone</code> trait itself
should be implemented automatically. It is convenient, but it leaves a very
grey area concerning which traits ought to be implemented for compiler-generated
types, and the most conservative option would be to require an opt-in for all
traits beyond the basic <code>Fn</code> traits (in the case of function types).</p>
<h3 id="unnatural-ness-of-using-default-trait"><a class="header" href="#unnatural-ness-of-using-default-trait">Unnatural-ness of using <code>Default</code> trait</a></h3>
<p>Several people objected on the grounds that <code>Default</code> was the wrong trait,
or that the resulting code seemed unnatural or confusing. This lead to
proposals involving other traits which will be described in their own
sections.</p>
<ul>
<li>
<p>Some people do not see <code>Default</code> as being equivalent to the
default-constructible concept from C++, and instead see it as something
more specialized.</p>
<p>To avoid putting words in people's mouths I'll quote @Mark-Simulacrum
directly:</p>
<blockquote>
<p>I think the main reason I'm not a fan of adding a Default impl here is
because you (probably) would never actually use it really as a &quot;default&quot;;
e.g. Vec::resize'ing with it is super unlikely. It's also not really a
Default but more just &quot;the only value.&quot; Certainly the error message telling
me that Default is not implemented for &amp;fn() {foo} is likely to be pretty
confusing since that does have a natural default too, like any pointer to
ZST). That's in some sense just more broadly true though.</p>
</blockquote>
</li>
<li>
<p>There were objections on the grounds that <code>Default</code> is not sufficient to
guarantee <em>uniqueness</em> of the function value. Code could be written today that
exposes a public API with a <code>Default + Fn()</code> bound, expecting all types
meeting that bound to have a single unique value.</p>
<p>If we expanded the set of types which could implement <code>Default + Fn()</code> (such
as by stabilizing <code>Fn</code> trait implementations or by making more function
types implement <code>Default</code>) then the assumptions of such code would be
broken.</p>
<p>On the other hand, we really can't stop people from writing faulty code and
this does not seem like a footgun people are going to accidentally use, in
part because it's so obscure.</p>
</li>
</ul>
<h3 id="new-lang-item"><a class="header" href="#new-lang-item">New lang-item</a></h3>
<p>This was a relatively minor consideration, but it is worth noting that this
solution would require making <code>Default</code> a lang item.</p>
<h2 id="safe-transmute"><a class="header" href="#safe-transmute">Safe transmute</a></h2>
<p>This proposal was to materialize the closure using the machinery being
added with the &quot;safe transmute&quot; RFC to transmute from the unit <code>()</code> type.</p>
<p>The details of how this would work in practice were not discussed in detail,
but there were some salient points:</p>
<ul>
<li>
<p>This solves the &quot;uniqueness&quot; problem, in that ZSTs are by definition unique.</p>
</li>
<li>
<p>It does not help with the &quot;privacy leakage&quot; concerns.</p>
</li>
<li>
<p>It opens up a new can of worms relating to the fact that ZST closure types
may still have upvars.</p>
</li>
<li>
<p>Several people expressed something along the lines of:</p>
<blockquote>
<p>if we were going to have a trait that allows this, it might as well be
Default, because telling people &quot;no, you need the special default&quot; doesn't
really help anything.</p>
</blockquote>
<p>Or, that if it's possible to do this one way with safe code, it should be
possible to do it in every way that makes sense.</p>
</li>
</ul>
<h2 id="singleton-or-zst-trait"><a class="header" href="#singleton-or-zst-trait"><code>Singleton</code> or <code>ZST</code> trait</a></h2>
<p>New traits were proposed to avoid using <code>Default</code> to materialize the function
values. The considerations here are mostly the same as for the &quot;safe
transmute&quot; propsal. One note is that if we <em>were</em> to add a <code>Singleton</code> trait,
it would probably make sense for that trait to inherit from the <code>Default</code>
trait anyway, and so a <code>Default</code> implementation now would be
backwards-compatible.</p>
<h2 id="fnstatic-trait"><a class="header" href="#fnstatic-trait"><code>FnStatic</code> trait</a></h2>
<p>This would be a new addition to the set of <code>Fn</code> traits which would allow
calling the function without any <code>self</code> argument at all. As the most
restrictive (for the callee) and least restrictive (for the caller) it
would sit at the bottom of the <code>Fn</code> trait hierarchy and inherit from <code>Fn</code>.</p>
<ul>
<li>Would be easy to understand for users already familiar with the <code>Fn</code> trait hierarchy.</li>
<li>More unambiguously describes a closure with no upvars rather than one which is a ZST.</li>
<li>Doesn't solve the problem of accidentally leaking capabilities.</li>
<li>Does not force a decision on whether closures should implement <code>Default</code>.</li>
</ul>
<p>This approach would also generalize the existing closure -&gt; function pointer
conversion for closures which have no upvars. Instead of being special-cased
in the compiler, the conversion can apply to all types implementing <code>FnStatic</code>.
Furthermore, the conversion could be implemented by simply returning a pointer
to the <code>FnStatic::call_static</code> function, which makes this very elegant.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>With this trait, we can implement <code>call_me_back_safely</code> from the prior example
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{panic, process};

pub fn call_me_back_safely&lt;F: FnStatic()&gt;(_f: F) {
    extern &quot;C&quot; fn catch_unwind_wrapper&lt;F: FnStatic()&gt;() {
        if panic::catch_unwind(F::call_static).is_err() {
            process::abort();
        }
    }
    unsafe {
        c_api::call_me_back(catch_unwind_wrapper::&lt;F&gt;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="const-eval"><a class="header" href="#const-eval">Const-eval</a></h2>
<p>Initially proposed by @scalexm, this solution uses the existing implicit
conversion from function types to function pointers, but in a const-eval
context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_one_adapter&lt;const F: fn(i32)&gt;(arg: i32) {
    F(arg + 1);
}

fn get_adapted_function_ptr&lt;const F: fn(i32)&gt;() -&gt; fn(i32) {
    add_one_adapter::&lt;F&gt;
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Avoids many of the pitfalls with implementing <code>Default</code>.</li>
<li>Requires giving up the original function type. There could be cases where
you still need the original type but the conversion to function pointer
is irreversible.</li>
<li>It's not yet clear if const-evaluation will be extended to support this
use-case.</li>
<li>Const evaluation has its own complexities, and given that we already have
unique function types, it seems like the original problem should be solvable
using the tools we already have available.</li>
</ul>
<h2 id="opt-in-trait-implementations"><a class="header" href="#opt-in-trait-implementations">Opt-in trait implementations</a></h2>
<p>This was barely touched on during the discussions, but one option would be to
have traits be opted-in via a <code>#[derive(...)]</code>-like attribute on functions and
closures.</p>
<ul>
<li>Gives a lot of power to the user.</li>
<li>Quite verbose.</li>
<li>Solves the problem of leaking capabilities.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-traits"><a class="header" href="#auto-traits">Auto traits</a></h1>
<p>Auto traits permit automatically implementing a trait for types which contain
fields implementing the trait. That is, they are fairly close to an automatic
derive. They describe properties of types rather than behaviors; current stable
Rust has several auto traits: <code>Send</code>, <code>Sync</code>, <code>Unpin</code>, <code>UnwindSafe</code>,
<code>RefUnwindSafe</code>.</p>
<p><code>Freeze</code> is also an auto trait indirectly observable on stable; it is used by
the compiler to determine which types can be placed in read-only memory, for
example.</p>
<p>Auto traits are tracked in <a href="https://github.com/rust-lang/rust/issues/13231">rust-lang/rust#13231</a>, and are also sometimes
referred to as OIBITs (&quot;opt-in built-in traits&quot;).</p>
<p>As of November 2020, the language team feels that new auto traits are unlikely
to be added or stabilized. See <a href="https://zulip-archive.rust-lang.org/213817tlang/73585Freezestabilizationandautotraitbackcompat.html">discussion</a> on the addition of <code>Freeze</code> for
context. There is a fairly high burden to doing so on the ecosystem, as it
becomes a concern of every library author whether to implement the trait or not.</p>
<p>Each auto trait represents a semver compatibility hazard for Rust libraries, as
adding private fields can remove the auto trait unintentionally from a type.</p>
<p>Stabilizing the ability to define auto traits also allows &quot;testing&quot; for the
absence of a specific type:</p>
<pre><code class="language-ignore">auto trait NoString {}
impl !NoString for String {}
</code></pre>
<p>This is not something we generally want to allow, as it makes almost any change
to types semver breaking. That means that stabilizing defining new auto traits is
currently unlikely.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eager-drop-design-note"><a class="header" href="#eager-drop-design-note">Eager drop design note</a></h1>
<ul>
<li>Project proposal <a href="https://github.com/rust-lang/lang-team/issues/86">rust-lang/lang-team#86</a></li>
</ul>
<h2 id="observations"><a class="header" href="#observations">Observations</a></h2>
<h3 id="any-attempt-to-make-drop-run-more-eagerly-will-have-to-take-borrows-into-account"><a class="header" href="#any-attempt-to-make-drop-run-more-eagerly-will-have-to-take-borrows-into-account">Any attempt to make drop run more eagerly will have to take borrows into account</a></h3>
<p>The original proposal was to use &quot;CFG dead&quot; as a criteria, but it's pretty clear that this will not work well. Example:</p>
<pre><pre class="playground"><code class="language-rust="><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = String::new();
    let y = &amp;x;
    // last use of x is here
    println!(&quot;{}&quot;, y);
    // but we use y here
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the fact that <code>y</code> (indirectly) uses <code>x</code> feels like an important thing to take into account.</p>
<h3 id="some-destructors-can-be-run-at-any-time"><a class="header" href="#some-destructors-can-be-run-at-any-time">Some destructors can be run &quot;at any time&quot;...</a></h3>
<p>Some destructors have very significant side-effects. The most notable example is dropping a lock guard.</p>
<p>Others correspond solely to &quot;releasing resources&quot;: freeing memory is the most common example, but another might be replacing an entry in a table because you are done using it.</p>
<h3 id="but-sometimes-that-significance-is-only-known-at-the-call-site"><a class="header" href="#but-sometimes-that-significance-is-only-known-at-the-call-site">...but sometimes that significance is only known at the call site</a></h3>
<p>However, it can be hard to know what is significant. For a lock guard, for example, if the lock is just being used to guard the data, then moving the lock release early is actually <em>desirable</em>, because you want to release the lock as soon as you are doing changing the data. But sometimes you have a <code>Mutex&lt;()&gt;</code>, in which case the lock has extra semantics. It's hard to know for sure.</p>
<h3 id="smarter-drop-placement-will-mean-that-adding-uses-of-a-variable-changes-when-its-destructor-runs"><a class="header" href="#smarter-drop-placement-will-mean-that-adding-uses-of-a-variable-changes-when-its-destructor-runs">Smarter drop placement will mean that adding uses of a variable changes when its destructor runs</a></h3>
<p>This is not necesarily a problem, but it's an obvious implication: right now, the drop always runs when we exit the scope, so adding further uses to a variable has no effect, but that would have to change. That could be surprising (e.g., adding a debug printout changes the time when a lock is released).</p>
<p>In contrast, if you add an early drop <code>drop(foo)</code> today, you get helpful error messages when you try to use it again.</p>
<p>In other words, it's useful to have the <em>destructor</em> occurring at a known time (sometimes...).</p>
<h3 id="todays-drop-rules-are-however-a-source-of-confusion"><a class="header" href="#todays-drop-rules-are-however-a-source-of-confusion">Today's drop rules are, however, a source of confusion</a></h3>
<p>The semantics of <code>let _ = &lt;expr&gt;</code> have been known to caught a lot of confusion, particularly given the interaction of place expressions and value expresssions:</p>
<ul>
<li><code>let _ = foo</code> -- no effect</li>
<li><code>let _ = foo()</code> -- immediately drops the result of invoking <code>foo()</code></li>
<li><code>let _guard = foo</code> -- moves <code>foo</code> into <code>_guard</code> and drops at the end of the block</li>
<li><code>let _guard = foo()</code> -- moves <code>foo()</code> into <code>_guard</code> and drops at the end of the block</li>
</ul>
<p>Another common source of confusion is the lifetimes of temporaries in <code>match</code> statements and the like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo.lock().data.copy_out() {
    ...
} // lock released here!
<span class="boring">}
</span></code></pre></pre>
<p><code>let guard = foo; ...; drop(guard);</code> has the advantage of explicitness, so does something like <code>foo.with(|guard| ...)</code></p>
<h3 id="clarity-for-unsafe-code-can-be-quite-important"><a class="header" href="#clarity-for-unsafe-code-can-be-quite-important">Clarity for unsafe code can be quite important</a></h3>
<p>There are known footguns today with the timing of destructors and unsafe code. For example, <code>CString::new().as_ptr()</code> is a common thing people try to do that does not work. Eager destructors would enable more motion, which might exacerbate the problem.</p>
<p>In addition, unsafe code means we might not be able to know the semantics associated with a destructor, such as what precisely a <code>Mutex&lt;()&gt;</code> guards, and moving a drop earlier <em>will</em> break some unsafe code in hard-to-detect ways.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<ul>
<li>Scoped methods</li>
<li>let blocks</li>
<li>&quot;Defer&quot; type constructs or scoped guard type constructs from other languages
<ul>
<li>Go</li>
<li>D</li>
<li>Python</li>
</ul>
</li>
<li>Built-in macros or RAII/closure-based helpers in the standard library.
<ul>
<li>Note that the <a href="https://crates.io/crates/scopeguard">scopeguard</a> crate offers macros like <code>defer!</code> that inject a let into the block.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autorefautoderef-in-operators"><a class="header" href="#autorefautoderef-in-operators">Autoref/Autoderef in operators</a></h1>
<p>Rust permits overriding most of the operators (e.g., <code>+</code>, <code>-</code>, <code>+=</code>). In part
due to <code>Copy</code> types not auto-dereferencing, it is common to have <code>T + &amp;T</code>
or <code>&amp;T + &amp;T</code>, with potentially many levels of indirection on either side of the
operator.</p>
<p>There is desire in general to avoid needing to both add impls for referenced
versions of types because they:</p>
<ul>
<li>bloat documentation</li>
<li>are never quite sufficient (always more references are possible)</li>
<li>can cause inference regressions, as the compiler cannot in general know that
<code>&amp;T + &amp;T</code> is essentially equivalent at runtime to <code>T + T</code>.</li>
</ul>
<p>The inference regressions are the primary target of historical discussions.</p>
<p>The tradeoff to some feature like this may either mean that the exact impl
executed at runtime is harder to determine, or that the compiler is
synthetically generating new implementations for some subset of types,
potentially adding confusion around which impls are actually present.</p>
<p>However, generic code may want the impls on references because the generic code
may not want to require <code>T: Copy</code>. One version of this could involve
something like <code>default impl&lt;T:Copy&gt; Add&lt;&amp;T&gt; for &amp;T</code> so that people don't <em>need</em>
to write special impls themselves. It's worth noting that this still would need
some special support in the compiler to avoid the two possible impls leading to
inference regressions.</p>
<h2 id="history-2"><a class="header" href="#history-2">History</a></h2>
<p>The standard library initially had just the basic impls of the operator traits
(e.g., <code>impl Add&lt;u64&gt; for u64</code>) but has since gained <code>&amp;u64 + &amp;u64</code>, <code>u64 + &amp;u64</code>
and <code>&amp;u64 + u64</code>. These impls usually cause some amount of inference breakage in
practice.</p>
<p>Especially with non-Copy types (for example bigints), forcing users to add references can be
increasingly verbose: <code>&amp;u * &amp;(&amp;(&amp;u.square() + &amp;(&amp;a * &amp;u)) + &amp;one)</code>, for example.</p>
<p>There have also been a number of discussions on RFCs and issues, including:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/44762">Rust tracking issue #44762</a>
<ul>
<li>This includes some implementation/mentoring notes.</li>
</ul>
</li>
<li><a href="https://github.com/rust-lang/rfcs/pull/2147">RFC 2147</a></li>
<li><a href="https://github.com/rust-lang/rust/pull/41336">Trying to add T op= &amp;T</a>
<ul>
<li>Showcases dealing with inference breakage regressions when adding new
reference-taking impls.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-type-ergonomics"><a class="header" href="#copy-type-ergonomics">Copy type ergonomics</a></h1>
<h2 id="background-2"><a class="header" href="#background-2">Background</a></h2>
<p>There are a number of pain points with <code>Copy</code> types that the lang team is
interested in exploring, though active experimentation is not currently ongoing.</p>
<p>Some key problems are:</p>
<h2 id="copy-cannot-be-implemented-with-non-copy-members"><a class="header" href="#copy-cannot-be-implemented-with-non-copy-members"><code>Copy</code> cannot be implemented with non-<code>Copy</code> members</a></h2>
<p>There are standard library types where the lack of a <code>Copy</code> impl is an
active pain point, e.g., <a href="https://github.com/rust-lang/rust/issues/62835"><code>MaybeUninit</code></a>
and <a href="https://github.com/rust-lang/rust/issues/25053"><code>UnsafeCell</code></a>, when the
contained type is actually <code>Copy</code>.</p>
<h3 id="history-3"><a class="header" href="#history-3">History</a></h3>
<ul>
<li><code>unsafe impl Copy for T</code> which avoids the requirement that T is recursively
Copy, but is obviously unsafe.
<ul>
<li>https://github.com/rust-lang/rust/issues/25053#issuecomment-218610508</li>
</ul>
</li>
<li><code>Copy</code> is dangerous on types like <code>UnsafeCell</code> where <code>&amp;UnsafeCell&lt;T&gt;</code>
otherwise would not permit access to <code>T</code> in <a href="https://github.com/rust-lang/rust/issues/25053#issuecomment-98447164">safe
code</a>.</li>
</ul>
<h2 id="copy-types-can-be-unintentionally-copied"><a class="header" href="#copy-types-can-be-unintentionally-copied"><code>Copy</code> types can be (unintentionally) copied</a></h2>
<p>Even if a type is Copy (e.g., <code>[u8; 1024]</code>) it may not be a good idea to make
use of that in practice, since copying large amounts of data is slow. This is
primarily a performance concern, so the problem is usually that these copies are
easy to miss. However, depending on the size of the buffer, it can also be a
correctness concern as it may cause an unintended stack overflow with too many
accidental copies.</p>
<p>Should we want to lint on this code, deciding on a size threshold may be
difficult. It's not generally possible for the compiler to know whether a
particular copy operation is likely to lead to stack overflow or undesirable
performance. We don't have examples yet of cases where there's desirable large
copies (that should not be linted against) or concrete cases where the copies
are accidental; collecting this information would be worthwhile.</p>
<p>Implementations of <code>Copy</code> on closures and arrays are the prime example of Rust
currently being overeager with the defaults in some contexts.</p>
<p>This also comes up with <code>Copy</code> impls on <code>Range</code>, which would generally be
desirable but is error-prone given the <code>Iterator/IntoIterator</code> impls on ranges.</p>
<p>The example here does not compile today (since Range is not Copy), but would be
unintuitive if it did.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0..10;
let mut c = move || x.next();
println!(&quot;{:?}&quot;, x.next()); // prints 0
println!(&quot;{:?}&quot;, c()); // prints 0, because the captured x is implicitly copied.
<span class="boring">}
</span></code></pre></pre>
<p>This example illustrates the range being copied into the closure, while the user
may have expected the name &quot;x&quot; to refer to the same range in both cases.</p>
<p>The move keyword here likely disambiguates this particular case for users, but
in closures with more captures it may be not as obvious that the range type in
particular was copied in.</p>
<p>A lint has been <a href="https://github.com/rust-lang/rust/issues/45683">proposed</a> to
permit Copy impls on types where Copy is likely not desirable with particular
conditions (e.g., Copy of IntoIterator-implementing types after iteration).</p>
<p>Note that &quot;large copies&quot; comes up with moves as well (which are copies, just
taking ownership as well), so a size-based lint is plausibly desirable for both.</p>
<h3 id="history-4"><a class="header" href="#history-4">History</a></h3>
<ul>
<li>Proposed lint: <a href="https://github.com/rust-lang/rust/issues/45683">#45683</a></li>
</ul>
<h2 id="references-to-copy-types"><a class="header" href="#references-to-copy-types">References to <code>Copy</code> types</a></h2>
<p>Frequently when dealing with code generic over T you end up needing things like
<code>[u8]::contains(&amp;5)</code> which is ugly and annoying. Iterators of copy types also
produce <code>&amp;&amp;u64</code> and similar constructs which can produce unexpected type errors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for x in &amp;vec![1, 2, 3, 4, 5, 6, 7] {
    process(*x); // &lt;-- annoying that we need `*x`
}

fn process(x: i32) { }
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum_even(v: &amp;[u32]) -&gt; u32 {
    // **v is annoying
    v.iter().filter(|v| **v % 2 == 0).sum()
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that this means that you in most cases want to &quot;boil down&quot; to the inner
type when dealing with references, i.e., <code>&amp;&amp;u32</code> you actually want <code>u32</code>, not
<code>&amp;u32</code>. Notably, though, this may <em>not</em> be true if the Copy type is something
more complex (e.g., a future Copy Cell), since then <code>&amp;Cell</code> is quite different
from a <code>Cell</code>, the latter being likely useless for modification at least.</p>
<p>There is also plausibly performance left on the table with types like <code>&amp;&amp;u64</code>.</p>
<p>Note that this interacts with the unintentional copies (especially of large
structures).</p>
<p>This could plausibly be done with moved values as well, so long as the
semantics match the syntax (e.g. <code>wants_ref(foo)</code> acts like <code>wants_ref(&amp;{foo})</code>)
similar to how one can pass <code>&amp;mut</code> to something that only wants <code>&amp;</code>.
This would be a tradeoff: in some cases people may want the type-checker to flag such cases and require explicitly taking a reference, while in other cases people may want the compiler to automatically make such code work. We would want to consider and evaluate this tradeoff, and whether we can usefully separate such cases.</p>
<h3 id="history-5"><a class="header" href="#history-5">History</a></h3>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/pull/2111">RFC 2111 (not merged)</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/44763">Rust tracking issue (closed)</a></li>
<li>&quot;Allow owned values where references are expected&quot; in <a href="https://github.com/rust-lang/rust-roadmap-2017/issues/17">rust-roadmap-2017#17</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>This section contains lang-team roadmaps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lang-team-roadmap-2024"><a class="header" href="#lang-team-roadmap-2024">Lang Team Roadmap 2024</a></h1>
<p>Rust 1.0 was released in 2015. Since that time, we've seen Rust grow from a
small language used for a handful of prominent projects into a mainstay in use
at virtually every major tech company.</p>
<p>As we work towards Rust 2024, it's natural to ask what's next for the language.
This roadmap provides insight into that question by describing what we, as
members of the lang team with input from other Rust teams, would like to
prioritize.</p>
<p>We have two goals with this roadmap:</p>
<ul>
<li>to give people a sense for what to expect in Rust over the next few years;</li>
<li>for those who would like to contribute to Rust, to help provide &quot;starting
points&quot; for how to get involved, and a sense for what kind of projects we are
looking for.</li>
</ul>
<h2 id="rust-2024-scaling-empowerment"><a class="header" href="#rust-2024-scaling-empowerment">Rust 2024: scaling empowerment</a></h2>
<p>Rust's goal is to <strong>empower everyone to build reliable and efficient
software</strong>. Success requires not only designing and implementing a great
language with great libraries and great tools, but also maintaining a great and
supportive community.</p>
<p>Our focus for Rust 2024 is to <strong>scale empowerment</strong> in many different ways. As
we grow, we face increasing challenges in how we can scale the ways in which we
empower people to an increasing number of people. This roadmap presents three
general themes we plan to focus on:</p>
<ul>
<li><strong><a href="roadmaps/roadmap-2024.html#Theme-Flatten-the-learning-curve">Flatten the (learning) curve</a></strong>:
scaling to new users and new use cases
<ul>
<li>Make Rust more accessible to new and existing users alike, and make
solving hard problems easier.</li>
</ul>
</li>
<li><strong><a href="roadmaps/roadmap-2024.html#Theme-Help-users-help-each-other">Help Rust's users help each other</a></strong>:
scaling the ecosystem
<ul>
<li>Empower library authors so they can---in turn---empower their users.</li>
</ul>
</li>
<li><strong><a href="roadmaps/roadmap-2024.html#Theme-Help-the-Rust-project-scale">Help the Rust project scale</a></strong>:
scaling the project
<ul>
<li>Develop processes to scale to the needs and use cases of a growing number
of users; evaluate and finish projects we've started.</li>
</ul>
</li>
</ul>
<p>For each theme, we'll describe our goals for Rust 2024, and give a few examples
of the kinds of things that we're working on right now, as well as the kinds of
things we would like to do over the next few years.</p>
<p>This roadmap is a starting point. Our intent is to highlight those areas that
will have the biggest impact on Rust's success. Specific examples will change
over time, whether because they're finished or because new proposals arise. As
2023 approaches, we will revisit these themes to see how much progress we have
made, and whether we wish to adjust the list.</p>
<h2 id="theme-flatten-the-learning-curve"><a class="header" href="#theme-flatten-the-learning-curve">Theme: Flatten the (learning) curve</a></h2>
<h3 id="the-vision"><a class="header" href="#the-vision">The vision</a></h3>
<p>Thanks to a consistent focus on ergonomics, Rust has become considerably easier
to use over the last few years. Companies building large teams of Rust users
report that the typical onboarding time for a Rust engineer is around 3-6
months. Of course, once folks learn Rust, they typically love it. Even so, many
people report a sense of high &quot;cognitive overhead&quot; in using it, and &quot;learning
curve&quot; remains the most common reason not to use Rust. The fact is that, even
after you learn how the Rust borrow checker works, there remain a lot of &quot;small
details&quot; that you have to get just right to get your Rust program to compile.</p>
<p>For Rust 2024, we will identify and eliminate many of those patterns and
idiosyncracies that one must learn to use Rust; our goal is to let you focus
squarely on the &quot;inherent complexity&quot; of your problem domain and avoid
&quot;accidental complexity&quot; from Rust as much as possible.</p>
<p>Async and embedded Rust are areas of particular interest. We have made a lot of
strides to support those areas, and they are growing rapidly. Nonetheless, Rust
lacks many core capabilities that would be required to make working in those
domains not only <em>possible</em> but <em>straightforward and delightful</em>. For Rust
2024, we will close that gap.</p>
<p>Our plan for achieving this vision is to focus on four high-level goals (in
order from broad to precise):</p>
<ul>
<li><strong>More precise analyses, less rigamarole:</strong> Make the compiler better able to
recognize when code is correct via improvements to the borrow checker, type
inference, and so forth. Identify and eliminate &quot;boilerplate&quot; patterns like
having to copy-and-paste the same set of where clauses everywhere.</li>
<li><strong>Express yourself more easily:</strong> Where necessary, extend the language so you
can express what you want your code to do more directly. In some cases this
takes the form of syntactic sugar (such as
<a href="https://github.com/rust-lang/rust/issues/87335">let-else</a>) but in other
cases it may mean extending the type system to be able to describe new
patterns (such as <a href="https://rust-lang.github.io/generic-associated-types-initiative/">generic associated
types</a>).</li>
<li><strong>Improve async support:</strong> Extend our async-await support beyond the current
&quot;MVP&quot; to include features like async fns in traits, async drop, and other
features needed to support the <a href="https://rust-lang.github.io/wg-async/vision/roadmap.html">async vision
document</a> roadmap.</li>
<li><strong>Make <code>dyn Trait</code> more usable:</strong> Broaden the set of traits that can be used
with <code>dyn</code> and make working with <code>dyn</code> closer to working with generics.</li>
</ul>
<h3 id="how-you-can-help"><a class="header" href="#how-you-can-help">How you can help</a></h3>
<p>Join the rust-lang Zulip, and either start a thread in the
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
stream, or send a private message to nikomatsakis if you'd like to discuss
privately first.</p>
<h3 id="the-plan-so-far"><a class="header" href="#the-plan-so-far">The plan (so far)</a></h3>
<p>Current active <a href="https://lang-team.rust-lang.org/initiatives.html">initiatives</a>
in each category include:</p>
<ul>
<li><strong>More precise analyses, less rigamarole:</strong>
<ul>
<li>Non-lexical lifetimes were a big stride forward, but the <a href="https://github.com/rust-lang/polonius/">polonius
project</a> promises to improve the
borrow check's precision even more.</li>
<li><a href="https://github.com/rust-lang/rust/issues/44491">Implied bounds</a> promise
to remove a lot of copy-and-pasting of where clauses.</li>
</ul>
</li>
<li><strong>Express yourself more easily:</strong>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/87335">let-else</a> directly
express the &quot;match this variant or <code>return</code>/<code>continue</code>/etc&quot; pattern.</li>
<li><a href="https://github.com/rust-lang/rust/issues/53667">let-chains</a> allow you to
express iterative refinement with a series of pattern-matches and
conditionals</li>
<li><a href="https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html">&quot;Type alias&quot; impl
Trait</a>
permits APIs to name previously unnameable types. This is part of a
larger effort to <a href="https://rust-lang.github.io/impl-trait-initiative/">expand impl
Trait</a>.</li>
<li><a href="https://rust-lang.github.io/generic-associated-types-initiative/">Generic associated
types</a>
allow traits to express a number of patterns (like &quot;iterable&quot;) that the
current trait system cannot handle. They are a particularly important
foundational piece for async programming.</li>
</ul>
</li>
<li><strong>Improve async support:</strong>
<ul>
<li>We are working to support <a href="https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_traits.html">async fns in
traits</a>,
including both static dispatch and dyn dispatch.</li>
</ul>
</li>
<li><strong>Make <code>dyn Trait</code> more usable:</strong>
<ul>
<li><a href="https://github.com/rust-lang/dyn-upcasting-coercion-initiative/issues/6">Dyn upcasting coercion
initiative</a>:
Allow upcasting <code>dyn trait</code> objects from <code>&amp;dyn Subtrait</code> to <code>&amp;dyn Supertrait</code>.</li>
<li>The <a href="https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_traits.html">async fn in
traits</a>
initiative is also extending dyn trait to support async fns and &quot;return
position impl Trait&quot;.</li>
</ul>
</li>
</ul>
<h3 id="looking-forward"><a class="header" href="#looking-forward">Looking forward</a></h3>
<p>Looking beyond the initiatives that are in progress, there's a lot of room for
more improvement. Here are some other ideas we'd like to see. <strong>For many of
these ideas, the main thing they need is someone to own the design!</strong> If you
might be interested in giving that a try, come to
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
to discuss, or send a private message to nikomatsakis.</p>
<ul>
<li><strong>More precise analyses, less rigamarole:</strong>
<ul>
<li><a href="https://github.com/rust-lang/lang-team/issues/88">Deref patterns</a>:
Permit matching types with patterns they can dereference to, such as
matching a <code>String</code> with a <code>&quot;str&quot;</code>.</li>
<li>Perfect derive: determine the precise conditions for generic type
parameters based on the types of a struct fields. For instance,
<code>#[derive(Clone)] struct MyStruct(Rc&lt;T&gt;)</code> would not require <code>T: Clone</code>,
because <code>Rc&lt;T&gt;</code> can be cloned without it.</li>
<li>Autoref, operators, and clones: Generic methods that operate on
references sometimes necessitate types like <code>&amp;u32</code>; since <code>u32</code> is
<code>Copy</code>, we could automatically make it a reference. We've historically
had some hesitance to add more reference-producing operations, because it
can lead to types the user doesn't expect (such as <code>&amp;&amp;&amp;str</code>). We have
some ideas to simplify those cases and avoid unnecessary
double-references.</li>
</ul>
</li>
<li><strong>Express yourself more easily:</strong>
<ul>
<li><a href="https://github.com/rust-lang/lang-team/issues/137">Generators</a>, allowing
users to write iterators (async and otherwise) using custom syntax.</li>
</ul>
</li>
<li><strong>Improve async support:</strong>
<ul>
<li>After adding async fn in traits, we intend to add support for async drop,
async closures, and potentially other features.</li>
</ul>
</li>
<li><strong>Make <code>dyn Trait</code> more usable:</strong>
<ul>
<li>Make more patterns &quot;object safe&quot; and thus usable in <code>dyn Trait</code> objects,
including passing <code>self</code> by value and handling <code>impl Trait</code> in argument
position (<a href="https://smallcultfollowing.com/babysteps/blog/2022/01/07/dyn-async-traits-part-7/">see this post for more
information</a>).</li>
</ul>
</li>
</ul>
<h2 id="theme-help-users-help-each-other"><a class="header" href="#theme-help-users-help-each-other">Theme: Help users help each other</a></h2>
<h3 id="the-vision-1"><a class="header" href="#the-vision-1">The vision</a></h3>
<p>Rust's combination of ownership and borrowing, low-level systems control, and
powerful extensibility mechanisms like procedural macros makes it a great
language for writing libraries. And, thanks to Cargo, using a library in your
program only takes a few lines of code. Nonetheless, there are a number of
things that library authors <em>can't</em> do, or can't do easily -- for example, they
can't control the error messages you see or deploy an &quot;unstable&quot; feature that
requires special opt-in to use. For Rust 2024, we want to build features that
empower library authors to better serve their users, either by helping to
manage the feature lifecycle or by expanding the capabilities of what a library
can do.</p>
<p>We encourage people to experiment and explore in the library ecosystem,
building new functionality for people to use. Sometimes, that new functionality
becomes a foundation for others to build on, and standardizing it simplifies
further development atop it, letting the cycle continue at another level.
However, some aspects of the Rust language (notably coherence) make it harder
to extend the Rust standard library or well-established crates from separate
libraries, discouraging experimentation. Other features (such as aspects of
method resolution) make it hard to promote best-in-class functionality into the
standard library or into well-established crates without breaking users of the
crates that first developed that functionality. For Rust 2024, we want to
pursue changes that enable more exploration in the ecosystem, and enable stable
migration of code from the ecosystem into the standard library.</p>
<p>Our plan for achieving this vision is to focus on four categories of work:</p>
<ul>
<li><strong>Feature lifecycle</strong>: Help library authors support features as they move
from experimental to finalized. Help library authors manage their development
lifecycle and evolution.</li>
<li><strong>Richer abstractions</strong>: Extend the language to let library authors express
richer abstractions.</li>
<li><strong>Custom developer experience</strong>: Permit library authors can tailor the
developer experience, for example by tailoring the error messages a user gets
when traits are not implemented or introducing custom lints.</li>
<li><strong>Interoperability</strong>: The library ecosystem can easily coordinate, making
libraries work together without tying them together. Library authors can
write code that is portable across many environments or specific to one, as
they please.</li>
</ul>
<h3 id="how-you-can-help-1"><a class="header" href="#how-you-can-help-1">How you can help</a></h3>
<p>Join the rust-lang Zulip, and either start a thread in the
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
stream, or send a private message to Josh Triplett if you'd like to discuss
privately first.</p>
<h3 id="the-plan-so-far-1"><a class="header" href="#the-plan-so-far-1">The plan (so far)</a></h3>
<p>Current active <a href="https://lang-team.rust-lang.org/initiatives.html">initiatives</a>
in each category include:</p>
<ul>
<li><strong>Feature lifecycle:</strong>
<ul>
<li>RFC 3240 proposes <a href="https://github.com/rust-lang/rfcs/pull/3240">edition-based method
disambiguation</a>, to support
moving extension methods from external crates into the standard library.</li>
</ul>
</li>
<li><strong>Richer abstractions:</strong>
<ul>
<li>There are numerous core extensions to Rust's type system that permit
richer traits to be developed. Often the lack of these features prohibits
people from writing general purpose libraries because they can't get
sufficient reuse:
<ul>
<li><a href="https://rust-lang.github.io/async-fundamentals-initiative/">Async fn in
traits</a></li>
<li><a href="https://github.com/rust-lang/lang-team/issues/51">Const generics</a>
and <a href="https://github.com/rust-lang/lang-team/issues/22">constant
evaluation</a></li>
<li><a href="https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html">Type alias impl
Trait</a></li>
<li><a href="https://rust-lang.github.io/generic-associated-types-initiative/">Generic associated
types</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>Custom developer experience:</strong>
<ul>
<li>We are not currently doing any coordinated initiatives here, though there
are ongoing efforts that help lay groundwork for this.</li>
</ul>
</li>
<li><strong>Interoperability:</strong>
<ul>
<li>Support &quot;global capabilities&quot; like allocators or async runtimes, perhaps
via an approach like <a href="https://github.com/rust-lang/rfcs/pull/2492">RFC
2492</a>, and perhaps extending
to something like <a href="https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/">scoped contexts and
capabilities</a>.</li>
<li><a href="https://rust-lang.github.io/negative-impls-initiative/">Negative impls in
coherence</a> allows
for more flexibility in the coherence check by permitting crates to
explicitly declare that a given type will never implement a given trait.</li>
<li>The async working group's <a href="https://www.ncameron.org/blog/portable-and-interoperable-async-rust/">portability
initiative</a>
(which builds on the work to support <a href="https://rust-lang.github.io/async-fundamentals-initiative/">async fn in
traits</a>) will
help the async ecosystem to grow by enabling more interoperability.</li>
</ul>
</li>
</ul>
<h3 id="looking-forward-1"><a class="header" href="#looking-forward-1">Looking forward</a></h3>
<p>Looking beyond the initiatives that are in progress, there's a lot of room for
more improvement. Here are some other ideas we'd like to see. <strong>For many of
these ideas, the main thing they need is someone to own the design!</strong> If you
might be interested in giving that a try, come to
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
to discuss, or send a private message to Josh Triplett.</p>
<ul>
<li><strong>Feature lifecycle</strong>:
<ul>
<li>All ecosystem crates can have &quot;release trains&quot;, with the equivalent of
&quot;nightly features&quot; that require a stability opt-ins. Top-level crates
retain control over whether any of their dependencies may use nightly
features.</li>
</ul>
</li>
<li><strong>Richer abstractions</strong>:
<ul>
<li>Allow libraries to implement the <code>Fn</code> traits to define callable objects.</li>
<li>Variadic tuples and variadic generics would address a common pain point
of &quot;implement this trait for tuples of any arity&quot;.</li>
</ul>
</li>
<li><strong>Custom developer experience</strong>:
<ul>
<li>Allow libraries to provide custom lints for their users.</li>
<li>Allow libraries to control or customize Rust diagnostics, especially for
trait resolution failures.</li>
</ul>
</li>
<li><strong>Interoperability</strong>:
<ul>
<li>Revive the stalled <a href="https://github.com/rust-lang/rfcs/pull/1868">portability
lint</a> or pursue an
alternative design (a recent suggestion is that the &quot;platform&quot; might be a
global service, similar to <a href="https://github.com/rust-lang/rfcs/pull/2492">RFC
2492</a>, permitting one to use
where clauses to designate portable code)</li>
<li>The coherence rules make it hard to implement interoperability traits; we
should find a way to lift this restriction, while preserving coherence's
key benefits.</li>
<li>Adopt a standard way to write performance benchmarks (perhaps simply
adopt <code>criterion</code> officially).</li>
<li>Better support for dynamic linking, with richer and safer types than the
C ABI. For instance, implement an <code>extern &quot;safe&quot;</code> providing a subset of
Rust's rich types.</li>
</ul>
</li>
</ul>
<h2 id="theme-help-the-rust-project-scale"><a class="header" href="#theme-help-the-rust-project-scale">Theme: <strong>Help the Rust project scale</strong></a></h2>
<h3 id="the-vision-2"><a class="header" href="#the-vision-2">The vision</a></h3>
<p>The Rust repo is a blizzard of activity. This is great, but it can be
overwhelming, particularly if you are trying to figure out the status of some
particular thing that you are interested in or would like to contribute to.</p>
<p>To ship Rust 2024 and make Rust all that it can be, we need a system that makes
it easy for people to find out what's going on and how they can help. We want
to scale our language development through delegation, empowering developers to
own and drive the work that they are passionate about. Lang team liaisons and
frequent lang team check-in will help ensure quality, stability, and overall
coherence. The team itself will have a clear &quot;path to membership&quot; that helps us
to maintain our membership and make sure we have the expertise we need.</p>
<p>Our plan for achieving this vision is to focus on four categories of work:</p>
<ul>
<li><strong>See the status at a glance:</strong> We want it to be easy to identify what things
the lang-team is actively working on and how far those designs have come. We
want every tracking issue to clearly identify what &quot;next steps&quot; are needed to
push that particular feature over the finish line and make sure that those
steps are clearly documented for would-be contributors.</li>
<li><strong>Clear owners and clear communication:</strong> Rust operates by consensus, but
that doesn't mean that everybody has to know all the details of everything.
We need a system that has clear owners for the work to be done, and ideally,
owners that are not on the lang team. Simply dividing work though can lead to
conflicts later on, so we also need frequent communication and updates to
ensure that everyone is keeping abreast of the overall direction things are
going, and to surface concerns early.</li>
<li><strong>Efficient, open processes with tooling support:</strong> We are always looking for
ways to improve how we operate to help us stay on top of what is going on in
the Rust project and to reach conclusions more quickly. One thing we've
noticed is that processes that are supported by bots or other tooling tend to
work much better.</li>
</ul>
<h3 id="how-you-can-help-2"><a class="header" href="#how-you-can-help-2">How you can help</a></h3>
<p>Join the rust-lang Zulip, and either start a thread in the
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
stream, or send a private message to Josh Triplett and nikomatsakis if you'd
like to discuss privately first.</p>
<h3 id="the-plan-so-far-2"><a class="header" href="#the-plan-so-far-2">The plan (so far)</a></h3>
<p>Current active <a href="https://lang-team.rust-lang.org/initiatives.html">initiatives</a>
in each category include:</p>
<ul>
<li><strong>See the status at a glance:</strong>
<ul>
<li>The <a href="https://github.com/orgs/rust-lang/projects/16/">initiative project
board</a> tracks all the
currently active initiatives that we are focusing on. For each one, it
shows their <a href="https://lang-team.rust-lang.org/initiatives/process/stages.html">current
stage</a>
along with their
<a href="https://lang-team.rust-lang.org/initiatives/process/roles/owner.html">owners</a>
and <a href="https://lang-team.rust-lang.org/initiatives/process/roles/liaison.html">lang-team
liaisons</a>.</li>
<li>During the <a href="https://lang-team.rust-lang.org/meetings/backlog-bonanza.html">backlog
bonanza</a>
meetings, we are going through each older tracking issue and identifying
what kinds of work is needed to move it forward (needs a summary, needs
design work, etc).</li>
<li>We're taking the time to stabilize features that people are using, and
remove incomplete features as well as features people are not using, with
the eventual goal of treating everything open as &quot;in-flight&quot; rather than
&quot;unknown&quot;. We will also reduce the total number of in-flight features.</li>
</ul>
</li>
<li><strong>Clear owners and clear communication:</strong>
<ul>
<li>The <a href="https://lang-team.rust-lang.org/initiatives.html">initiative system</a>
assigns each task an owner, who drives the design, as well as a lang-team
liaison, who helps ensure alignment with the team. More work is needed to
get this system up and running smoothly.</li>
<li>We are launching a <a href="https://hackmd.io/@nikomatsakis/rJ3h_-kJc">formality
team</a> that will take ownership
of ensuring Rust's type soundness and diving into the details. This will
help to grow the set of people with expertise in that area while also
allowing the main lang team to consult as needed.</li>
</ul>
</li>
<li><strong>Efficient, open processes with tooling support:</strong>
<ul>
<li>We have designed a new <a href="https://lang-team.rust-lang.org/decision_process.html">consensus decision
process</a> that is
designed to overcome some of the shortcomings we've seen with rfcbot; it
needs to be implemented. This will help us make easily reversible
decisions easier, enable more experimentation, make it smoother to raise
and resolve concerns, and keep track of potential issues from proposal
through to stabilization</li>
</ul>
</li>
</ul>
<h3 id="looking-forward-2"><a class="header" href="#looking-forward-2">Looking forward</a></h3>
<p>Looking beyond the initiatives that are in progress, there's a lot of room for
more improvement. Here are some other ideas we'd like to see. If you might be
interested in giving that a try, come to
<a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024"><code>#t-lang/roadmap-2024</code></a>
to discuss, or send a private message to Josh Triplett and nikomatsakis.</p>
<ul>
<li><strong>See the status at a glance:</strong>
<ul>
<li>Find ways to integrate the older tracking issues with active initiatives;
reduce the manual updates required to keep the project board in sync.</li>
<li>Improve the visualization of projects and blockers to something more
compelling and easier to follow.</li>
</ul>
</li>
<li><strong>Clear owners and clear communication:</strong>
<ul>
<li>Beyond the type system, there are other areas where forming specialized
teams could be useful.</li>
</ul>
</li>
<li><strong>Efficient, open processes with tooling support:</strong>
<ul>
<li>Generally improve rustbot to make meetings more efficient.</li>
<li>Improve and automate the process of going from initiative proposal to
tracked initiative.</li>
</ul>
</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>We hope that this post has given you a taste for what we plan to focus on over
the next few years. If you'd like to help us reach these goals, please <a href="https://rust-lang.zulipchat.com/#narrow/stream/318377-t-lang.2Froadmap-2024">get
involved</a>!
We've listed a number of active initiatives for each point, but we've also
included a lot of ideas that are looking for an owner. Whether you prefer to
code, design, document, or organize, there's work for you to do. And if the
only thing you want to do with Rust 2024 is to use it, we welcome that too.
Happy Rust hacking to y'all!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
